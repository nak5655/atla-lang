using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

using Atla.Lang;
using Atla.Lang.Hir;
using Atla.Lang.Mir;

// K正規化
// TODO Mir.from に変更(HIRがMIRの詳細に依存すべきではない)
namespace Atla.Lang.Hir
{
    [Record]
    public class KNormalExpr {
        public proc: IEnumerable[Mir.Ins];
        public res: option[Mir.Value]; // voidのときnone
    }
    
    variant Callable {
        | MethodInfo { methodInfo: System.Reflection.MethodInfo }
        | Inline { proc: Proc }
    }
    
    public class Trans
    {
        getCallable(mc: Mir.MethodContainer, scope: Hir.Scope, hir: Hir.Expr): Result[Callable] {
            match (hir) { 
                | Hir.Expr.Id(s, _) as id => {
                    def ty = hir.type.pruned();
                    match (id.getSymbol(scope)) {
                        | Some(sym) => match (sym.kind) {
                            | SymbolKind.Method(mi) => Result.Success(Callable.MethodInfo(mi))
                            | SymbolKind.InlineMethod(proc) => Result.Success(Callable.Inline(proc))
                            | _ => match (ty) {
                                | Atla.Lang.Type.Fn => Result.Success(Callable.MethodInfo(ty.ToSystemType().GetMethod("Invoke"))) // System.Func.Invoke や System.Action.Invoke など
                                | _ => Result.Failure($"$hir is not a function.")
                            }
                        }
                        | _ => Result.Failure($"$hir is not a function.")
                    }
                }
                | Hir.Expr.StaticMember(clsName, name) => {
                    mutable ty = scope.resolveType(clsName);
                    match (ty.pruned()) {
                        | Type.Native(nt) => {
                            def mi = nt.GetMethods().Find(methodInfo => {
                                if (methodInfo.Name == name) {
                                    match (hir.type.pruned()) {
                                        | it is Type.Fn => it.canUnify(methodInfo.toFnType(scope))
                                        | _ => true
                                    }
                                } else {
                                    false
                                }
                            });
                            if (mi.IsSome) {
                                Result.Success(Callable.MethodInfo(mi.Value))
                            } else {
                                Result.Failure("$hir does not exist.")
                            }
                        }
                        // TODO
                    }
                }
            }
        }
        
        public trans(mc: Mir.MethodContainer, frame: Frame, scope: Hir.Scope, hir: Hir.Stmt): Result[IEnumerable[Mir.Ins]] {
            match (hir) {
                | Hir.Stmt.Expr(e) => trans(mc, frame, scope, e).map(a => a.proc)
                | Hir.Stmt.Var(id, expr, _) => {
                    match (id.getSymbol(scope)) {
                        | Some(sym) => {
                            if (sym.isLocal()) {
                                frame.declareLocal(sym);
                            
                                def re = trans(mc, frame, scope, expr);
                                re.bind(e => match (e.res) {
                                     | Some(res) => Result.Success(e.proc.Concat([Mir.Ins.Assign(sym, res)]))
                                     | _ => Result.Failure($"$expr has no value.")
                                })
                            } else {
                                Result.Failure($"$(id.name) is not declared as local variable.")
                            }
                        }
                        | _ => Result.Failure($"$(id.name) does not exist in scope.")
                    }
                }
                | Hir.Stmt.Return(e) => {
                    mutable retScope = scope;
                    while (true) {
                        match (retScope) {
                            | it is Hir.Scope.Block => trans(mc, frame, scope, e).map(a => {
                                 // ブロックスコープならReturnじゃなくてJumpする
                                match (a.res) {
                                    | None => a.proc.Concat([Mir.Ins.Jump(it.endLabel)])
                                    | Some(v) => a.proc.Concat([Mir.Ins.Assign(it.retSymbol, v), Mir.Ins.Jump(it.endLabel)])
                                }
                            })
                            | it is Hir.Scope.Fn => trans(mc, frame, scope, e).map(a => {
                                match (a.res) {
                                    | Some(v) => a.proc.Concat([Mir.Ins.RetValue(v)])
                                    | _ => a.proc.Concat([Mir.Ins.Ret()])
                                }
                            })
                            | _ => {}
                        }
                    }
                    Result.Failure($"Could not find the return destination. $hir")
                }
                // TODO
            }
        }
        
        public trans(mc: Mir.MethodContainer, frame: Frame, scope: Hir.Scope, hir: Hir.Expr): Result[KNormalExpr] {
            match (hir) {
                // TODO
                | Hir.Expr.Unit => Result.Success(KNormalExpr([], None())) // TODO Unit Singleton
                | Hir.Expr.Bool(value) => Result.Success(KNormalExpr([], Some(Mir.Value.Imm(Mir.Imm.Bool(value)))))
                | Hir.Expr.Int(value) => Result.Success(KNormalExpr([], Some(Mir.Value.Imm(Mir.Imm.Int(value)))))
                | Hir.Expr.String(s) => Result.Success(KNormalExpr([], Some(Mir.Value.Imm(Mir.Imm.String(s)))))
                | Hir.Expr.Id(name, _) as id => {
                    match (id.getSymbol(scope)) {
                        | Some(sym) => match (sym.kind) {
                            | SymbolKind.Arg =>  match (NCollectionsExtensions.Find(frame.args, arg => arg.name == sym.name)) { // 同じ名前の引数はないので名前が一致すればいい
                                | Some(arg) => Result.Success(KNormalExpr([], Some(Mir.Value.Sym(arg))))
                                | None => Result.Failure($"Could not find $name in arguments.")
                            }
                            | SymbolKind.Local => match (NCollectionsExtensions.Find(frame.locs, loc => loc.name == sym.name && loc.type.canUnify(sym.type))) { // TODO 同値比較でいい?(symをそのままつかえばいい?)
                                | Some(loc) => Result.Success(KNormalExpr([], Some(Mir.Value.Sym(loc))))
                                | None => Result.Failure($"Could not find $name in locals.")
                            }
                        }
                        | _ => Result.Failure($"$name is not defined as $(id.type) type.")
                    }
                }
                | Hir.Expr.Apply(fn, args) => {
                    // 引数の評価順に注意
                    // K正規化
                    def kArgRs = args.Map(arg => trans(mc, frame, scope, arg));
                    foreach (kArgR in kArgRs) {
                        match (kArgR) {
                            | Result.Failure(e) => return Result.Failure(e)
                            | _ => ()
                        }
                    }
                    def kArgs = kArgRs.Map(a => a.getResult().Value);
                    
                    match (getCallable(mc, scope, fn)) {
                        | Result.Success(Callable.MethodInfo(m)) => {
                            mutable procArgs = kArgs.SelectMany(_.proc);
                            mutable resArgs = kArgs.Map(_.res).Filter(_.IsSome).Map(_.Value);
                            
                            // 引数がvoidのみの時
                            when (args.Length == 1 && args.First().type.isVoid()) {
                                procArgs = [];
                                resArgs = [];
                            }
                            
                            if (m.ReturnType == typeof(void)) {
                                // 返り値がvoidのとき
                                Result.Success(KNormalExpr(procArgs.Concat([Mir.Ins.Call(m, resArgs)]), None()))
                            } else {
                                def tmp = frame.declareTemp(m.ReturnType);
                            
                                Result.Success(KNormalExpr(procArgs.Concat([Mir.Ins.CallAssign(tmp, m, resArgs)]), Some(Mir.Value.Sym(tmp))))
                            }
                        }
                        | Result.Success(Callable.Inline(proc)) => {
                            def procArgs = kArgs.SelectMany(_.proc);
                            def resArgs = kArgs.Map(_.res).Filter(_.IsSome).Map(_.Value);
                            
                            match (fn.type.pruned()) {
                                | Atla.Lang.Type.Fn(_, ret) => {
                                    def tmp = frame.declareTemp(ret);
                                    // 引数の数を確認して呼び出し命令生成
                                    def body = match (proc) {
                                        | Proc.DstArg2(body) => body(tmp, resArgs.Nth(0), resArgs.Nth(1))
                                    };
                                    Result.Success(KNormalExpr(procArgs.Concat(body), Some(Mir.Value.Sym(tmp))))
                                }
                                | _ => Result.Failure($"$fn must be a function.")
                            }
                        }
                        | Result.Failure(e) => Result.Failure(e)
                    }
                }
                | Hir.Expr.Block(blockScope, ss) => {
                    // TODO Block.stmtsをlist[Stmt]にする
                    
                    // TODO 返り値がvoidの時
                    
                    // ブロックの帰り値を確保
                    when (!blockScope.retType.isVoid())
                        blockScope.retSymbol = frame.declareTemp(blockScope.retType);
                    
                    def stmts = ss.ToNList();
                    def body = if (stmts.Length > 0) {
                        match (stmts.Last()) {
                            | Hir.Stmt.Expr(e) => {
                                // 最後が式文のとき
                                if (stmts.Length > 1) {
                                    // 最後の式以外を変換
                                    mutable res = trans(mc, frame, blockScope, stmts.Head);
                                    foreach (s in stmts.Tail.Take(stmts.Length - 2)) {
                                        res = res.bind(xs => trans(mc, frame, blockScope, s).map(ys => xs.Concat(ys)));
                                    }
                                    // 最後の式の評価結果をblockの帰り値に代入
                                    def rc = trans(mc, frame, blockScope, e);
                                    res.bind(xs => rc.map(c => {
                                        match (c.res) {
                                            | Some(v) when !blockScope.retType.isVoid() => xs.Concat(c.proc).Concat([Mir.Ins.Assign(blockScope.retSymbol, v)])
                                            | _ => xs.Concat(c.proc)
                                        }
                                    }))
                                } else {
                                    // 式の評価結果をblockの帰り値に代入
                                    trans(mc, frame, blockScope, e).map(xs => {
                                        match (xs.res) {
                                            | Some(v) when !blockScope.retType.isVoid() => xs.proc.Concat([Mir.Ins.Assign(blockScope.retSymbol, v)])
                                            | _ => xs.proc
                                        }
                                    })
                                }
                            }
                            | _ => {
                                stmts.Tail.Fold(trans(mc, frame, blockScope, stmts.Head), (v, acc) => acc.bind(xs => trans(mc, frame, blockScope, v).map(ys => xs.Concat(ys))))
                            }
                        }
                    } else {
                        Result.Success([]) // TODO unitを返す
                    }
                    
                    if (blockScope.retType.isVoid()) {
                        body.bind(b => Result.Success(KNormalExpr(b, None())))
                    } else {
                        body.bind(b => Result.Success(KNormalExpr(b, Some(Mir.Value.Sym(blockScope.retSymbol)))))
                    }
                }
                | Hir.Expr.Fn => throw Exception("Internal Error") // Flatで取り除かれてるはず
                | Hir.Expr.Switch(ents) => {
                    mutable racc = Result.Success([]);
                    def endLabel = Mir.Label(); // switch式を抜けるラベル
                    def tmp = frame.declareTemp(hir.type.pruned().ToSystemType()); // switch式の結果
                    
                    def bodies = ents.Map(ent => (Mir.Label(), trans(mc, frame, scope, ent.body)));
                    
                    // 分岐命令
                    foreach (i in Enumerable.Range(0, ents.Count())) {
                        def ent = ents.Nth(i);
                        def (label, _) = bodies.Nth(i);
                        def mne = trans(mc, frame, scope, ent.pred);
                        racc = racc.bind(acc => mne.bind(ne => match (ne.res) {
                            // 条件式がTrueならbodyにジャンプ
                            | Some(v) => Result.Success(acc.Concat(ne.proc).Concat([
                                Mir.Ins.JumpTrue(v, label)
                            ]))
                            | _ => Result.Failure($"Switch Predicate $ent.pred is not a Value.")
                        }));
                    }
                    
                    // 分岐先
                    foreach (i in Enumerable.Range(0, ents.Count())) {
                        def ent = ents.Nth(i);
                        def (label, rbody) = bodies.Nth(i);
                        racc = racc.bind(acc => rbody.bind(body => match (body.res) {
                            | Some(v) => {
                                // 分岐ラベルに続けてボディを追加
                                Result.Success(acc.Concat([Mir.Ins.MarkLabel(label)]).Concat(body.proc).Concat([
                                    Mir.Ins.Assign(tmp, v),
                                    Mir.Ins.Jump(endLabel), // 分岐の終わりまでジャンプ
                                ]))
                            }
                            | _ => Result.Failure($"Switch Entry $ent should return a Value.")
                        }));
                    }
                    
                    racc.map(r => KNormalExpr(r.Concat([Mir.Ins.MarkLabel(endLabel)]), Some(Mir.Value.Sym(tmp))))
                }
            }
        }
         
        public trans(import: Hir.Import): void {
            // TODO
            //| Hir.Decl.Import(name) => {
            //    def type = System.Type.GetType(name);
            //    typeTable.Add(name, Hir.Type.Native(type));
            //    // TODO: ドット区切り対応 System.Console を Console として追加登録する
            //    []
            //}
        }
        
        public addMethod(mc: Mir.MethodContainer, scope: Hir.Scope, hir: Hir.Method): Result[Mir.Method] {
            def type = hir.fn.type.pruned();
            match (type) {
                | Type.Fn => ()
                | _ => return Result.Failure($"$hir is $type, it should be a function.")
            }
            def fnType = type :> Type.Fn;
            
            def method = mc.defineMethod(hir.name, fnType.args.Map(_.ToSystemType()), fnType.ret.ToSystemType());
            foreach (i in Enumerable.Range(0, fnType.args.Length)) {
                match (hir.fn.scope.resolveArgNth(i)) {
                    | Some(sym) when sym.name == hir.fn.args.Nth(i).name => method.frame.declareArg(sym) // 一応名前チェックする
                    | _ => return Result.Failure($"Failed to create method frame. Could not find the argument $(hir.fn.args.Nth(i).name) in function scope.")
                }
            }
            
            // Bodyを変換する前にSymbolにMethodInfoを設定する（再帰関数に対応できる）
            match (scope.resolveVar(hir.name, fnType)) {
                | Some(Symbol as sym) => sym.kind = SymbolKind.Method(method.builder)
                | _ => return Result.Failure($"Could not resolve method $(hir.name) as $fnType.")
            }
            
            Result.Success(method)
        }
        
        public implMethod(mc: Mir.MethodContainer, hir: Hir.Method, mir: Mir.Method): Result[Mir.Method] {
            match (trans(mc, mir.frame, hir.fn.scope, hir.fn.body)) {
                | Result.Success(proc) => mir.body = match (proc.res) {
                    | Some(r) => proc.proc.Concat([Mir.Ins.RetValue(r)]).ToList().ToNList();
                    | _ => proc.proc.Concat([Mir.Ins.Ret()]).ToList().ToNList()
                }
                | Result.Failure(e) => return Result.Failure(e);
            }
            
            Result.Success(mir)
        }
        
        public generateModule(asm: Mir.Assembly, hir: Hir.Module): Result[Mir.Module] {
            def mod = Mir.Module(asm, hir.name);
            
            // TODO type definitions
            
            // 先に関数の宣言だけして、そのあと関数本体を変換する
            foreach ((m, r) in hir.methods.Map(m => (m, addMethod(mod, hir.scope, m)))) {
                match (r) {
                    | Result.Failure(e) => return Result.Failure(e);
                    | Result.Success(method) => {
                        match (implMethod(mod, m, method)) {
                            | Result.Failure(e) => return Result.Failure(e);
                            | _ => {}
                        }
                    }
                }
            }
          
            Result.Success(mod)
        }
        
        public trans(asm: Hir.Assembly): Result[Mir.Assembly] {
            def mir = Mir.Assembly(asm.name, asm.fileName);
            foreach ((name,mod) in asm.modules.KeyValuePairs) {
                match (generateModule(mir, mod)) {
                    | Result.Success(m) => mir.modules[name] = m
                    | Result.Failure(e) => return Result.Failure(e)
                }
                
            }
            Result.Success(mir)
        }
    }
}
