using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Atla.Lang.Hir
{
    // 関数の入れ子を外に出す(Expr.Fn -> Method)
    public class Flat
    {
        mutable _seqId: int = -1;
        getUniqueName(): string {
            _seqId += 1;
            $"closure`$_seqId"
        }
        
        replaceFn(scope: Hir.Scope, hir: Hir.HasExpr): IEnumerable[Type.Class] {
            mutable ret: List[Type.Class] = List();
            hir.replaceExpr(scope, (s, e) => match (e) {
                | Hir.Expr.Fn as f => {
                    // bodyはすでに置換済みなので注意（Bottom-Upなので）
                    
                    // クロージャーを表すクラスを作成
                    def fClass = Type.Class(scope.globalScope(), getUniqueName());
                    
                     // コンストラクタ作成
                    def fClassCtor = Hir.Expr.Fn(fClass.scope, []);
                    fClass.methods.Add(Hir.Method("ctor", fClassCtor)); // TODO コンストラクタの表現方法(とりあえず名前をctorにする)
                    ret.Add(fClass);
                    
                    // クラスのインスタンスのシンボル
                    def fClassInst = scope.declareLocal(getUniqueName(), fClass);
                    
                    // クロージャー内の自由変数を置換しながら列挙
                    def freeVars: List[string * Symbol] = List(); // 新たなフィールド名 * 元のシンボル
                    f.body.replaceExpr(f.scope, (s, e) => match (e) {
                        | Hir.Expr.Id as it => match (it.getSymbol(s)) {
                            | Some(sym) => {
                                // スコープの深さから自由変数を判定する
                                if (sym.depth < f.scope.depth) {
                                    // クロージャークラスのフィールドアクセスに置換
                                    def fieldName = $"freeVar`$(freeVars.Count())";
                                    freeVars.Add(fieldName, sym);
                                    Hir.Expr.Member(Hir.Expr.Id(fClassInst), fieldName)
                                } else {
                                    e
                                }
                            }
                            | _ => e
                        }
                        | _ => e
                    });
                    
                    // 自由変数を除いた関数本体をクラス内に定義
                    fClass.methods.Add(Hir.Method("closure`invoke", f));
                    
                    // 元の関数式をクロージャーに置き換え
                    def block = Hir.Expr.Block(s);
                    block.stmts.AddRange([
                        // コンストラクタ呼び出し
                        //Hir.Stmt.Let(Hir.Expr.Id(fClassInst), Hir.Expr.Apply(Hir.Expr.StaticMember()), false),
                    ]);
                    block
                }
                | _ => e
            });
            
            ret
        }
        
        public flat(hir: Hir.Method): IEnumerable[Type.Class] {
            replaceFn(hir.fn.scope, hir.fn.body)
        }
        
        public flat(hir: Hir.Module): void {
            mutable newClasses: IEnumerable[Type.Class] = [];
            foreach (method in hir.methods) {
                newClasses = newClasses.Concat(flat(method));
            }
            hir.classes.AddRange(newClasses);
        }
        
        public flat(hir: Hir.Assembly): void {
            foreach (mod in hir.modules.Values) {
                flat(mod);
            }
        }
    }
}
