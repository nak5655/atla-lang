using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;

using System;
using System.Collections.Generic;
using System.Linq;

using Atla.Lang;
using Atla.Lang.Parse;


/**
脱糖済み
型推論の対象
第一級関数の展開
**/
namespace Atla.Lang.Hir
{
    public variant Error {
        | DuplicatedDeclaration { name: string; type: Type; already: Type }
        | UndefinedReference {
            name: string; type: Atla.Lang.Type;
            
            public override ToString(): string {
                $"Undefined variable. $name: $type"
            }
        }
        | Type {
            value: TypeError;
            
            public override Equals(other: object): bool {
                match (other) {
                    | Error.Type(te) => value.Equals(te)
                    | _ => false
                }
            }
            
            public override GetHashCode(): int {
                value.GetHashCode()
            }
        }
    }
    
    public variant Pattern: HasSpan[Pattern] {
        | Any
        | Int { value: int }
        
        public scanErrors(): IEnumerable[(Error * Span)] {
            [] // TODO
        }
    }
    
    public variant Stmt: HasSpan[Expr] {
        | Expr { expr: Hir.Expr }
        | Let { name: string; expr: Hir.Expr }
        | Assign { name: string; expr: Hir.Expr }
        | Return { value: Hir.Expr }
        
        public errors: List[Error] = List();
        
        public scanErrors(): IEnumerable[(Error * Span)] {
            def es = match (this) {
                | Expr(e) => e.scanErrors()
                | Let(_, e) => e.scanErrors()
                | Assign(_, e) => e.scanErrors()
                | Return(e) => e.scanErrors()
            }
            errors.Map(e => (e, span)).Concat(es)
        }
    }
    
    public class SwitchEntry: HasSpan[SwitchEntry] {
        public bodyScope: Scope.Block;
        public pred: Expr;
        public body: Expr;
        
        public this(bodyScope: Scope.Block, pred: Expr, body: Expr) {
            this.bodyScope = bodyScope;
            this.pred = pred;
            this.body = body;
        }
        
        public scanErrors(): IEnumerable[(Error * Span)] {
            pred.scanErrors().Concat(body.scanErrors())
        }
    }
    
    public class MatchEntry: HasSpan[MatchEntry] {
        public scope: Scope.Block;
        public pattern: Pattern;
        public expr: Expr;
        
        public this(scope: Scope.Block, pattern: Pattern, expr: Expr) {
            this.scope = scope;
            this.pattern = pattern;
            this.expr = expr;
        }
        
        public scanErrors(): IEnumerable[(Error * Span)] {
            pattern.scanErrors().Concat(expr.scanErrors())
        }
    }
    
    public class FnArg: HasSpan[FnArg] {
        public name: string;
        
        public this(name: string) {
            this.name = name;
        }
        
        public override ToString(): string {
            $"$name"
        }
    }
    
    public variant Expr: HasSpan[Expr] {
        | Unit {
            public override ToString(): string {
                "Unit"
            }
        }
        | Bool {
            public value: bool;
            
            public override ToString(): string {
                $"Bool($value)"
            }
        }
        | Int {
            public value: int;
            
            public override ToString(): string {
                $"Int($value)"
            }
        }
        | String {
            public value: string;
            
            public override ToString(): string {
                $"String($value)"
            }
        }
        | Block {
            public scope: Scope.Block;
            public mutable stmts: List[Stmt] = List();
            
            public this(parentScope: Scope) {
                this.scope = Scope.Block(parentScope, None());
            } 
            
            public override ToString(): string {
                def stmtsStr = stmts.joinToString(", ");
                $"Block($stmtsStr)"
            }
        }
        | Switch {
            public entries: list[SwitchEntry];
        }
        | Match {
            public scope: Scope.Block;
            public expr: Expr;
            public entries: list[MatchEntry];
        }
        | Fn {
            public args: list[FnArg];
            public mutable body: Expr;
            public scope: Scope.Fn;
            
            public this(parentScope: Scope, args: list[string]) {
                this.args = args.Map(a => FnArg(a));
                // TODO ブロックスコープで引数を宣言
                this.scope = Scope.Fn(parentScope);
            }
            
            public override ToString(): string {
                def argsStr = args.joinToString(", ");
                $"Fn($argsStr) { $body }"
            }
        }
        | Id {
            public name: string;
            // TODO option[Symbol]をもつ?
            
            public override ToString(): string {
                $"Id($name)"
            }
        }
        | Member {
            public expr: Expr;
            public name: string;
            
            public override ToString(): string {
                $"Member($expr, $name)"
            }
        }
        | StaticMember {
            public clsName: string;
            public name: string;
            
            public override ToString(): string {
                $"StaticMember(clsName, $name)"
            }
        }
        | Apply {
            public fn: Expr;
            public args: list[Expr];
            
            public override ToString(): string {
                def argsStr = args.joinToString(", ");
                $"Apply($fn, $argsStr)"
            }
        }
        
        public mutable typeHint: TypeHint = TypeHint.None();
        public mutable type: Type.Var = Type.Var();
        public errors: List[Error] = List();
        
        // TODO Type.Varのエラーが重複する
        public scanErrors(): IEnumerable[(Error * Span)] {
            def es = match (this) {
                | Unit => []
                | Bool => []
                | Int => []
                | String => []
                | Block(_, ss) => ss.SelectMany(_.scanErrors())
                | it is Fn => it.body.scanErrors()
                | Id => []
                | Member(e, _) => e.scanErrors()
                | StaticMember => []
                | Apply(fn, args) => fn.scanErrors().Concat(args.SelectMany(_.scanErrors()))
                | Switch(es) => es.SelectMany(_.scanErrors())
                | Match(_, e, es) => e.scanErrors().Concat(es.SelectMany(_.scanErrors()))
            }
            errors.Map(e => (e, span)).Concat(es).Concat(type.scanErrors().Select(e => (Error.Type(e), span)))
        }
    }
    
    [Record]
    public class Import {
        public path: list[string];
        
        public dotted(): string {
            def sb = System.Text.StringBuilder();
            when (path.Length > 0)
                _ = sb.Append(path.First());
            when (path.Length > 1) {
                foreach (s in path.Tail) {
                    _ = sb.Append("." + s);
                }
            }            
            sb.ToString()
        }
        
        // TODO: errors
    }
    
    public class Module {
        public name: string; // TODO scope.nameを返す
        public imports: List[Import];
        public mutable members: Hashtable[string, List[Expr.Fn]]; // overloads
        
        public scope: Scope.Module;
        
        public this(parentScope: Scope.Global, name: string) {
            this.name = name;
            imports = List();
            members = Hashtable();
            
            this.scope = Scope.Module(parentScope, name);
        }
        
        public import(path: list[string]): void {
            imports.Add(Import(path))
            // TODO edit scope
        }
        
        public declareFn(name: string, fn: Expr.Fn): void {
            when (!members.ContainsKey(name))
                members.Add(name, List());
            
            def overloads = members[name];
            overloads.Add(fn)
        }
        
        public scanErrors(): IEnumerable[(Error * Span)] {
            members.Values.SelectMany(_.SelectMany(_.scanErrors()))
        }
    }
    
    public class Assembly {
        public name: string;
        public fileName: string;
        public modules: Hashtable[string, Module];
        
        public scope: Scope.Global; // TODO Scope.Assembly? 外部アセンブリへの依存の扱いをどうするか決めてない
        
        public this(name: string, fileName: string) {
            this.name = name;
            this.fileName = fileName;
            this.modules = Hashtable();
            
            scope = Scope.Global();
        }
        
    }
}
