using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;

using System;
using System.Collections.Generic;
using System.Linq;
using Atla.Lang.Parse;


/**
脱糖済み
型推論の対象
第一級関数の展開
**/
namespace Atla.Lang.Hir
{
    public variant Error {
        | DuplicatedDeclaration { name: string; type: Type; already: Type }
        | TypeUnificationFailure { refered: Type; referer: Type }
        | TypeRecursiveReference { a: Type; b: Type }
        | UndefinedReference { name: string; type: Type }
        | UndefinedType { name: string }
        | TypeInferenceFailure
        | AmbiguousType { types: list[Type] }
        | TypeInferenceUnmatched { types: list[Type] }
    }
    
    public variant Stmt: HasSpan[Expr] {
        | Expr { expr: Hir.Expr }
        | Let { name: string; expr: Hir.Expr }
        | Assign { name: string; expr: Hir.Expr }
        | Return { value: Hir.Expr }
        
        public mutable errors: List[Error];
        
        public addError(err: option[Error]): void {
            match (err) {
                | Some(e) => errors.Add(e)
                | _ => {}
            }
        }
    }
    
    public class FnArg: HasSpan[FnArg] {
        public name: string;
        public typeVar: Hir.TypeVar = TypeVar();
        
        public this(name: string) {
            this.name = name;
        }
    }
    
    public variant Expr: HasSpan[Expr] {
        | Unit
        | Int {
            public value: int;
        }
        | String {
            public value: string;
        }
        | Block {
            public scope: Scope;
            public mutable stmts: List[Stmt] = List();
            
            public this(parentScope: Scope) {
                this.scope = Scope(parentScope);
            } 
        }
        | Fn {
            public args: list[FnArg];
            public mutable body: Expr;
            public scope: Scope;
            
            public this(parentScope: Scope, args: list[string]) {
                this.args = args.Map(a => FnArg(a));
                // TODO ブロックスコープで引数を宣言
                this.scope = Scope(parentScope);
            }
        }
        | Id { name: string }
        | Member { expr: Expr; name: string }
        | Apply { fn: Expr; args: list[Expr] }
        
        public typeVar: Hir.TypeVar = TypeVar();
        public mutable errors: List[Hir.Error] = List();
        
        public addError(err: option[Error]): void {
            match (err) {
                | Some(e) => errors.Add(e)
                | _ => {}
            }
        }
    }
    
    [Record]
    public class Import {
        public path: list[string];
        
        public dotted(): string {
            def sb = System.Text.StringBuilder();
            when (path.Length > 0)
                _ = sb.Append(path.First());
            when (path.Length > 1) {
                foreach (s in path.Tail) {
                    _ = sb.Append("." + s);
                }
            }            
            sb.ToString()
        }
    }
    
    public class Module {
        public name: string;
        public imports: List[Import];
        public mutable members: Hashtable[string, list[Expr]]; // overloads
        
        public scope: Scope;
        
        public this(name: string) {
            this.name = name;
            imports = List();
            members = Hashtable();
            
            scope = Scope();
        }
        
        public import(path: list[string]): void {
            imports.Add(Import(path))
            // TODO edit scope
        }
        
        public declareFn(name: string, fn: Expr.Fn): void {
            
        }
    }
}
