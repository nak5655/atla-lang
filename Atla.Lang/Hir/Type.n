using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using Atla.Lang.Parse;
using Atla.Lang;

namespace Atla.Lang.Hir
{
    public class TypeVar {
        public hints: List[TypeHint] = List();
        public mutable type: option[Type] = None();
            
        public this() { }
            
        public this(hint: TypeHint) {
            hints.Add(hint);
        }
            
        public addHint(hint: TypeHint): void {
            hints.Add(hint);
        }
        
        // type型として解決する
        public resolveAs(type: Type): void {
            this.type = Some(type);
        }
        
        // type型として解釈できるか
        public judge(type: Type): bool {
            hints.All(_.judge(type))
        }
        
        // typeHintsからtypeを推論する
        public infer(): Type {
            when (type.IsSome) {
                return type.Value
            }
            
            foreach (hint in hints) {
                // TODO
                def hintType = match (hint) {
                    | Name(scope, s) => {
                        scope.resolveType(s).WithDefault(Type.Error(Hir.Error.UndefinedType(s)))
                    }
                    | Fn(args, ret) => {
                        Type.Fn(args.Map(_.infer()), ret.infer());
                    }
                    | BehaveAs(v) => {
                        // TODO 循環参照危ないかも
                        v.infer()
                    }
                    | BehaveAsOneOf(vs) => {
                        def ts = vs.Filter(v => hint.judge(v.infer())).Map(_.infer());
                        if (ts.Count() == 1) {
                            ts.First()
                        } else if (ts.Count() == 0) {
                            Type.Error(Hir.Error.TypeInferenceUnmatched(vs.Map(_.infer())))
                        } else {
                            Type.Error(Hir.Error.AmbiguousType(ts))
                        }
                    }
                }
                type = Some(type.Map(t => t.unified(hintType)).WithDefault(hintType))
            }
            
            when (type.IsNone) {
                type = Some(Type.Error(Hir.Error.TypeInferenceFailure()))
            }
            
            type.Value
        }
        
        public override ToString(): string {
            match (type) {
                | Some(t) => t.ToString()
                | _ => Misc.joinToString(" + ", hints)
            }
        }
    }
    
    public variant TypeHint: HasSpan[TypeHint] {
        | Name {
            scope: Scope;
            name: string;
            
            public override ToString(): string {
                name
            }
        }
        | Fn {
            args: list[TypeVar]; ret: TypeVar;
            
            public override ToString(): string {
                def sb = StringBuilder();
                if (args.Length > 0) {
                    _ = sb.Append(args.Head.ToString());
                    foreach (arg in (args.Tail + [ret])) {
                        _ = sb.Append(" -> ").Append(arg.ToString());
                    }
                } else {
                    _ = sb.Append(ret.ToString());
                }
                sb.ToString()
            }
        }
        | Generics { _base: TypeVar; _params: list[TypeVar] }
        | BehaveAs { var: TypeVar }
        | BehaveAsOneOf {
            types: list[TypeVar];
        } // 順不同検索: Private Search Engine - Brave Search
        | NoneOf { types: list[TypeVar] }
        
        // TODO recursive type reference
        public judge(type: Type): bool { match (this) {
            | Hir.TypeHint.Name(scope, name) => match (type) {
                | Native(t) => match (scope.resolveType(name)) {
                    | Some(Native(s)) => t.Equals(s) // Need Test
                    | _ => false
                }
                | Class => match (scope.resolveType(name)) {
                    | Some(s) => type.Equals(s) // Need Test
                    | _ => false
                }
                | _ => false
            }
            | Hir.TypeHint.Fn(args, ret) => match (type) {
                | f is Type.Fn when f.args.Length == args.Length => args.Zip(f.args).All((c, t) => c.judge(t)) && ret.judge(f)
                | Native => false // TODO
                | _ => false
            }
            | Hir.TypeHint.Generics(_base, _params) => match (type) {
                | Type.Generics(b, ps) when _params.Length == ps.Length => _base.judge(b) && ps.Zip(_params).All((p, _p) => _p.judge(p))
                | _ => false
            }
            | Hir.TypeHint.BehaveAs(var) => {
                var.hints.All(_.judge(type))
            }
            | Hir.TypeHint.BehaveAsOneOf(vars) => {
                vars.Count(v => {
                    v.hints.All(_.judge(type))
                }) == 1
            }
            | Hir.TypeHint.NoneOf(vars) => {
                !vars.Any(v => {
                    v.hints.All(_.judge(type))
                })
            }
        }}
    }
    
    public variant Type {
        | Class {  }
        | Native {
            type: System.Type;
            
            public override ToString(): string {
                type.Name
            }
            
            public override Equals(other: object): bool {
                match (other) {
                    | Native(t) => t.Equals(type)
                    | _ => false
                }
            }
        }
        | Fn {
            args: list[Type]; ret: Type;
            
            public override ToString(): string {
                def a = Misc.joinToString(", ", args);
                $"($a): $ret"
            }
        }
        | Generics { _base: Type; _params: list[Type] }
        | Error {
            public this(error: Hir.Error) {
                this.errors.Add(error);
            }
            
            public this(errors: IEnumerable[Hir.Error]) {
                this.errors.AddRange(errors);
            }
        }
        
        public members: Hashtable[string, List[Expr]] = Hashtable();
        public errors: List[Hir.Error] = List();
        
        public unified(other: Type): Type {
            match ((this, other)) {
                | (e is Error, _) => Type.Error(e.errors.ToNList() + [Hir.Error.TypeUnificationFailure(this, other)])
                | (_, e is Error) => Type.Error(e.errors.ToNList() + [Hir.Error.TypeUnificationFailure(other, this)])
                | (Fn(a, b), Fn(c, d)) when a.Length == c.Length => Fn(a.Zip(c).Map((x,y) => x.unified(y)), b.unified(d))
                | (Native(a), Native(b)) when a.Equals(b) => this // TODO ネイティブの継承を考慮する
                // TODO
                | _ => Type.Error(Hir.Error.TypeUnificationFailure(this, other))
            }
        }
    }
}
