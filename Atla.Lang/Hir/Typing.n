using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Atla.Lang.Hir
{
    public class Typing
    {
        public this() {
        }
        
        public typing(hir: Hir.Module): void {
            foreach (import in hir.imports) {
                // TODO: import atla module (non Native)
                hir.scope.declareType(import.dotted(), Hir.Type.Native(System.Type.GetType(import.dotted())))
                // TODO: short name (e.g. System.Type as Type)
            }
            
            // first, declare members
            foreach ((id, member) in hir.members.KeyValuePairs) {
                foreach (overload in member) {
                    hir.scope.declareVar(id, overload.type)
                }
            }
            // next, analyze the type hints.
            foreach ((_, member) in hir.members.KeyValuePairs) {
                foreach (overload in member) {
                    typing(hir.scope, overload, Type.Unknown());
                }
            }
        }
        
        // トップダウンで型を構築してボトムアップで型推論
        public typing(scope: Scope, hir: Hir.Expr, expected: Type): void {
            hir.type.unify(hir.typeHint.resolve(scope));
            hir.type.unify(expected);
            
            match (hir) {
                | Unit => hir.type.unify(scope.globalScope().resolveType(Scope.unitTypeName)) // オーバーロード対策で念のためGlobalScopeで名前解決する
                | Int => hir.type.unify(scope.globalScope().resolveType(Scope.intTypeName))
                | String => hir.type.unify(scope.globalScope().resolveType(Scope.stringTypeName))
                | Block(blockScope, stmts) => {
                    foreach (stmt in stmts) {
                        typing(blockScope, stmt);
                    }
                    
                    when (stmts.Count() > 0) {
                        match (stmts.Last()) {
                            | Hir.Stmt.Expr(e) => blockScope.retType.unify(e.type)  // ブロックの最後の式は返り値とする
                            | Hir.Stmt.Return => ()
                            | _ => blockScope.retType.unify(scope.globalScope().resolveType(Scope.unitTypeName)) // ただの文ならunit型とする
                        }
                    }
                    
                    
                    // スコープの返り値で推論
                    hir.type.unify(blockScope.retType);
                }
                | Fn(args, body, bodyScope) => {
                    def fnType: Type.Fn = match (hir.type.unVar()) {
                        | it is Type.Fn => it
                        | _ => Type.Fn(args.Map(_ => Type.Var()), Type.Var())
                    }
                    // 引数を関数本体で宣言
                    foreach ((arg, t) in args.Zip(fnType.args)) {
                        bodyScope.declareVar(arg.name, t);
                    }
                    bodyScope.retType.unify(fnType.ret);
                    typing(bodyScope, body, fnType.ret);
                    
                    hir.type.unify(fnType);
                }
                | Id(name) => {
                    def var = scope.resolveVar(name, expected);
                    var.unify(expected);
                    hir.type.unify(var);
                }
                | Member(expr, name) => typing(scope, expr, Type.Unknown())
                | Apply(fn, args) => {
                    // 先に関数を解決してみる
                    typing(scope, fn, Type.Unknown());
                    
                    // 関数の型をもとに引数の型を推論
                    def argTypes = match (fn.type.unVar()) {
                        | Type.Fn(ts, _) when args.Length == ts.Length => ts
                        | _ => args.Map(_ => Type.Unknown())
                    }
                    foreach ((arg, t) in args.Zip(argTypes)) {
                        typing(scope, arg, t);
                    }
                    
                    // 引数の型をもとに関数の型を解決
                    def fnType = Type.Fn(args.Map(_.type), expected);
                    typing(scope, fn, fnType);
                    
                    // 返り値の型で型推論
                    match (fn.type.unVar()) {
                        | Fn(_, ret) => hir.type.unify(ret)
                        | _ => {}
                    }
                }
            }
        }
        
        // 型の関係式をトップダウンで構築
        public typing(scope: Hir.Scope, hir: Hir.Stmt): void {
            match (hir) {
                | Hir.Stmt.Let(name, rhs) => {
                    typing(scope, rhs, Type.Unknown()); // TODO type hint
                    scope.declareVar(name, rhs.type); // 右辺を処理してから変数宣言
                }
                | Hir.Stmt.Assign(name, rhs) => {
                    typing(scope, rhs, Type.Unknown());
                    // 右辺から左辺の型を推論
                    def destType = scope.resolveVar(name, Type.Unknown());
                    _ = destType.unify(rhs.type)
                }
                | Hir.Stmt.Expr(expr) => typing(scope, expr, Type.Unknown())
                | Hir.Stmt.Return(value) => {
                    typing(scope, value, Type.Unknown());
                    scope.retType.unify(value.type) // 返り値でスコープの型を推論
                }
            }
        }
    }
}
