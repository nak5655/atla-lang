using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;

using System;
using System.Collections.Generic;
using System.Linq;

using Atla.Lang;

namespace Atla.Lang.Hir
{
    public class Typing
    {
        public this() {
        }
        
        public typing(hir: Hir.Module): void {
            foreach (import in hir.imports) {
                // TODO: import atla module (non Native)
                def type = Type.Native(System.Type.GetType(import.dotted()));
                // declare short name (e.g. "System.String" is declared as "String")
                when (!import.path.IsEmpty()) {
                    hir.scope.declareType(import.path.Last(), type);
                }
            }
            
            // first, declare members
            foreach (method in hir.methods) {
                hir.scope.declareLocal(method.name, method.fn.type)
            }
            // next, analyze the type hints.
            foreach (method in hir.methods) {
                typing(hir.scope, method.fn, Type.Unknown());
            }
        }
        
        // トップダウンで型を構築してボトムアップで型推論
        public typing(scope: Scope, hir: Hir.Expr, expected: Type): void {
            hir.type.unify(hir.typeHint.resolve(scope));
            hir.type.unify(expected);
            
            match (hir) {
                | Unit => hir.type.unify(scope.globalScope().resolveType(Type.UNIT_NAME)) // オーバーロード対策で念のためGlobalScopeで名前解決する
                | Bool => hir.type.unify(scope.globalScope().resolveType(Type.BOOL_NAME))
                | Int => hir.type.unify(scope.globalScope().resolveType(Type.INT_NAME))
                | String => hir.type.unify(scope.globalScope().resolveType(Type.STRING_NAME))
                | Block(blockScope, stmts) => {
                    foreach (stmt in stmts) {
                        typing(blockScope, stmt);
                    }
                    
                    when (stmts.Count() > 0) {
                        match (stmts.Last()) {
                            | Hir.Stmt.Expr(e) => blockScope.retType.unify(e.type)  // ブロックの最後の式は返り値とする
                            | Hir.Stmt.Return => ()
                            | _ => blockScope.retType.unify(scope.globalScope().resolveType(Type.UNIT_NAME)) // ただの文ならunit型とする
                        }
                    }
                    
                    
                    // スコープの返り値で推論
                    hir.type.unify(blockScope.retType);
                }
                | Fn(args, body, bodyScope) => {
                    def fnType: Type.Fn = match (hir.type.unVar()) {
                        | it is Type.Fn => it
                        | _ => Type.Fn(args.Map(_ => Type.Var()), Type.Var())
                    }
                    // 引数を関数本体で宣言
                    foreach ((arg, t) in args.Zip(fnType.args)) {
                        bodyScope.declareArg(arg.name, t);
                    }
                    bodyScope.retType.unify(fnType.ret);
                    typing(bodyScope, body, fnType.ret);
                    
                    hir.type.unify(fnType);
                }
                | Id(name, _) as id => {
                    id.type.unify(expected);
                    match (id.getSymbol(scope)) {
                        | Some(var) => {
                            hir.type.unify(var.type);
                        }
                        | _ => hir.errors.Add(Error.UndefinedReference(name, expected))
                    }
                }
                | Member(expr, name) => {
                    typing(scope, expr, Type.Unknown())
                }
                | StaticMember(tyName, name) => {
                    mutable ty = scope.resolveType(tyName);
                    match (ty.pruned()) {
                        | Type.Class as cls => {
                            def es = cls.methods.Map(m => m.fn.type).Filter(_.canUnify(hir.type))
                                .Concat(cls.fields.Map(_.type).Filter(_.canUnify(hir.type)))
                                .NToList();
                            if (es.Length == 1) {
                                _ = hir.type.unify(es.First())
                            } else if (es.IsEmpty()) {
                                hir.type.errors.Add(TypeError.Undefined($"$tyName::$name"))
                            } else {
                               _ = hir.type.unify(Type.OneOf(es))
                            }
                        }
                        | Type.Native(nt) => {
                            // TODO クラス変数
                            def overloads = nt.GetMethods().Filter(methodInfo => {
                                if (methodInfo.Name == name) {
                                    match (hir.type.pruned()) {
                                        | it is Type.Fn => it.canUnify(methodInfo.toFnType(scope))
                                        | _ => true
                                    }
                                } else {
                                    false
                                }
                            });
                            if (overloads.Length == 1) {
                                _ = hir.type.unify(overloads.First().toFnType(scope))
                            } else if (overloads.Length > 1) {
                                _ = hir.type.unify(Type.OneOf(overloads.Map(m => m.toFnType(scope))))
                            } else {
                                hir.type.errors.Add(TypeError.Undefined($"$tyName::$name"))
                            }
                        }
                        | _ => hir.type.errors.Add(TypeError.Undefined(tyName))
                    }
                }
                | Apply(fn, args) => {
                    // 関数の型を特定したいので、先に引数の型を解析
                    foreach (arg in args) {
                        typing(scope, arg, Type.Unknown());
                    }
                    // 関数を解決
                    typing(scope, fn, Type.Fn(args.Map(_.type), expected));
                    
                    // 関数の型から引数と返り値を推論
                    match (fn.type.pruned()) {
                        | Type.Fn(xs, y) when xs.Length == args.Length => {
                            foreach ((arg, x) in args.Zip(xs)) {
                                arg.type.unify(x)
                            }
                            
                            hir.type.unify(y)
                        }
                        | Type.Error => () // エラーならそれ以上推論しない
                        | t => fn.type.errors.Add(TypeError.InferenceFailure($"Could not infer $t as a function."))
                    }
                }
                | Switch(entries) => {
                    foreach (entry in entries) {
                        // 条件式をBoolとして型推論
                        typing(scope, entry.pred, scope.globalScope().resolveType(Type.BOOL_NAME));
                        // bodyスコープでこの式の型として型推論
                        typing(entry.bodyScope, entry.body, hir.type);
                    }
                }
            }
        }
        
        // 型の関係式をトップダウンで構築
        public typing(scope: Hir.Scope, hir: Hir.Stmt): void {
            match (hir) {
                | Hir.Stmt.Var(id, rhs, _) => {
                    typing(scope, rhs, Type.Unknown()); // TODO type hint
                    id.symbolCache = Some(scope.declareLocal(id.name, rhs.type)); // 右辺を処理してから変数宣言
                }
                | Hir.Stmt.Assign(id, rhs) => {
                    typing(scope, rhs, Type.Unknown());
                    // 右辺から左辺の型を推論
                    id.type.unify(rhs.type);
                    match (id.getSymbol(scope)) {
                        | Some(dest) => {
                            _ = dest.type.unify(rhs.type)
                        }
                        | _ => hir.errors.Add(Hir.Error.UndefinedReference(id.name, rhs.type))
                    }
                }
                | Hir.Stmt.Expr(expr) => typing(scope, expr, Type.Unknown())
                | Hir.Stmt.Return(value) => {
                    typing(scope, value, Type.Unknown());
                    scope.retType().Map(t => t.unify(value.type)) // 返り値でスコープの型を推論
                }
            }
        }
    }
    
    public module HirTypingExtensions {
        public static toFnType(this methodInfo: System.Reflection.MethodInfo, scope: Scope): Atla.Lang.Type.Fn {
            def pTypes = methodInfo.GetParameters().Map(p => p.ParameterType);
            def argTypes = if (pTypes.IsEmpty())
                [scope.globalScope().resolveType(Type.UNIT_NAME)] // 引数がないときは代わりにUnitを引数とする
            else
                pTypes.Map(t => Type.Native(t)).ToNList();
            Atla.Lang.Type.Fn(argTypes, Type.Native(methodInfo.ReturnType));
        }
        
    }
}
