using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;

using System;
using System.Collections.Generic;
using System.Linq;

using Atla.Lang;

namespace Atla.Lang.Hir
{
    public class Typing
    {
        public this() {
        }
        
        public typing(hir: Hir.Module): void {
            foreach (import in hir.imports) {
                // TODO: import atla module (non Native)
                def type = Type.Native(System.Type.GetType(import.dotted()));
                // declare short name (e.g. "System.String" is declared as "String")
                when (!import.path.IsEmpty()) {
                    hir.scope.declareType(import.path.Last(), type);
                }
            }
            
            // first, declare members
            foreach ((id, member) in hir.members.KeyValuePairs) {
                foreach (overload in member) {
                    hir.scope.declareVar(id, overload.type)
                }
            }
            // next, analyze the type hints.
            foreach ((_, member) in hir.members.KeyValuePairs) {
                foreach (overload in member) {
                    typing(hir.scope, overload, Type.Unknown());
                }
            }
        }
        
        // トップダウンで型を構築してボトムアップで型推論
        public typing(scope: Scope, hir: Hir.Expr, expected: Type): void {
            hir.type.unify(hir.typeHint.resolve(scope));
            hir.type.unify(expected);
            
            match (hir) {
                | Unit => hir.type.unify(scope.globalScope().resolveType(Type.UNIT_NAME)) // オーバーロード対策で念のためGlobalScopeで名前解決する
                | Int => hir.type.unify(scope.globalScope().resolveType(Type.INT_NAME))
                | String => hir.type.unify(scope.globalScope().resolveType(Type.STRING_NAME))
                | Block(blockScope, stmts) => {
                    foreach (stmt in stmts) {
                        typing(blockScope, stmt);
                    }
                    
                    when (stmts.Count() > 0) {
                        match (stmts.Last()) {
                            | Hir.Stmt.Expr(e) => blockScope.retType.unify(e.type)  // ブロックの最後の式は返り値とする
                            | Hir.Stmt.Return => ()
                            | _ => blockScope.retType.unify(scope.globalScope().resolveType(Type.UNIT_NAME)) // ただの文ならunit型とする
                        }
                    }
                    
                    
                    // スコープの返り値で推論
                    hir.type.unify(blockScope.retType);
                }
                | Fn(args, body, bodyScope) => {
                    def fnType: Type.Fn = match (hir.type.unVar()) {
                        | it is Type.Fn => it
                        | _ => Type.Fn(args.Map(_ => Type.Var()), Type.Var())
                    }
                    // 引数を関数本体で宣言
                    foreach ((arg, t) in args.Zip(fnType.args)) {
                        bodyScope.declareArg(arg.name, t);
                    }
                    bodyScope.retType.unify(fnType.ret);
                    typing(bodyScope, body, fnType.ret);
                    
                    hir.type.unify(fnType);
                }
                | Id(name) => {
                    def var = scope.resolveVar(name, expected);
                    var.type.unify(expected);
                    hir.type.unify(var.type);
                }
                | Member(expr, name) => {
                    typing(scope, expr, Type.Unknown())
                }
                | StaticMember(tyName, name) => {
                    mutable ty = scope.resolveType(tyName);
                    match (ty.pruned()) {
                        | Type.Class(_, staticMembers) => {
                            def es = staticMembers.Get(name).Value.Filter(e => e.canUnify(hir.type));
                            if (es.Length == 1) {
                                _ = hir.type.unify(es.First())
                            } else if (es.IsEmpty()) {
                                hir.type.errors.Add(TypeError.Undefined($"$tyName::$name"))
                            } else {
                                hir.type.errors.Add(TypeError.Ambiguous(es))
                            }
                        }
                        | Type.Native(nt) => {
                            // TODO クラス変数
                            def overloads = nt.GetMethods().Filter(methodInfo => {
                                if (methodInfo.Name == name) {
                                    match (hir.type.pruned()) {
                                        | it is Type.Fn => it.canUnify(Type.Fn.from(methodInfo))
                                        | _ => true
                                    }
                                } else {
                                    false
                                }
                            });
                            if (overloads.Length == 1) {
                                _ = hir.type.unify(Type.Fn.from(overloads.First()))
                            } else if (overloads.Length > 1) {
                                hir.type.errors.Add(TypeError.Ambiguous(overloads.Map(m => Type.Fn.from(m))))
                            } else {
                                hir.type.errors.Add(TypeError.Undefined($"$tyName::$name"))
                            }
                        }
                        | _ => hir.type.errors.Add(TypeError.Undefined(tyName))
                    }
                }
                | Apply(fn, args) => {
                    // 関数の型を特定したいので、先に引数の型を解析
                    foreach (arg in args) {
                        typing(scope, arg, Type.Unknown());
                    }
                    // 関数を解決
                    typing(scope, fn, Type.Fn(args.Map(_.type), expected));
                    
                    // 関数の型から引数と返り値を推論
                    match (fn.type.pruned()) {
                        | Type.Fn(xs, y) when xs.Length == args.Length => {
                            foreach ((arg, x) in args.Zip(xs)) {
                                arg.type.unify(x)
                            }
                            
                            hir.type.unify(y)
                        }
                    }
                }
            }
        }
        
        // 型の関係式をトップダウンで構築
        public typing(scope: Hir.Scope, hir: Hir.Stmt): void {
            match (hir) {
                | Hir.Stmt.Let(name, rhs) => {
                    typing(scope, rhs, Type.Unknown()); // TODO type hint
                    scope.declareVar(name, rhs.type); // 右辺を処理してから変数宣言
                }
                | Hir.Stmt.Assign(name, rhs) => {
                    typing(scope, rhs, Type.Unknown());
                    // 右辺から左辺の型を推論
                    def dest = scope.resolveVar(name, Type.Unknown());
                    _ = dest.type.unify(rhs.type)
                }
                | Hir.Stmt.Expr(expr) => typing(scope, expr, Type.Unknown())
                | Hir.Stmt.Return(value) => {
                    typing(scope, value, Type.Unknown());
                    scope.retType().Map(t => t.unify(value.type)) // 返り値でスコープの型を推論
                }
            }
        }
    }
}
