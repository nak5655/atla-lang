using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Math;

using Atla.Lang;

namespace Atla.Lang.Hir
{
    public class Typing
    {
        public typing(hir: Hir.Assembly): void {
            foreach (mod in hir.modules.Values) {
                typing(mod);
            }
        }
        
        public typing(hir: Hir.Module): void {
            
            foreach (import in hir.imports) {
                def sysType = System.Type.GetType(import.dotted());
                if (sysType != null) {
                    def type = Type.Native(sysType);
                    _ = hir.scope.resolveType(import.path.Last()).unify(type);
                } else {
                    // TODO atlaモジュールを探す or .NETアセンブリを探す
                }
            }
            
            // next, analyze the type hints.
            foreach (ty in hir.types) {
                typing(hir.scope, ty);
            }
            foreach (method in hir.methods) {
                typing(hir.scope, method.fn, Type.Unknown());
            }
        }
        
        public typing(scope: Scope, hir: Atla.Lang.Type.Define): void {
            foreach (field in hir.fields) {
                _ = field.type.unify(field.typeHint.resolve(hir.scope))
            }
            foreach (method in hir.methods) {
                typing(hir.scope, method.fn, Type.Unknown());
            }
        }
        
        // トップダウンで型を構築してボトムアップで型推論
        public typing(scope: Scope, hir: Hir.Expr, expected: Type): void {
            _ = hir.type.unify(hir.typeHint.resolve(scope));
            _ = hir.type.unify(expected);
            
            match (hir) {
                | Unit => _ = hir.type.unify(Type.Unit)
                | Bool => _ = hir.type.unify(Type.Bool)
                | Int => _ = hir.type.unify(Type.Int)
                | Double => _ = hir.type.unify(Type.Double)
                | String => _ = hir.type.unify(Type.String)
                | Block(blockScope, stmts) => {
                    foreach (stmt in stmts) {
                        typing(blockScope, stmt);
                    }
                    
                    when (stmts.Count() > 0) {
                        match (stmts.Last()) {
                            | Hir.Stmt.Expr(e) => _ = blockScope.retType.unify(e.type)  // ブロックの最後の式は返り値とする
                            | Hir.Stmt.Return => ()
                            | _ => _ = blockScope.retType.unify(Type.Unit) // ただの文ならunit型とする
                        }
                    }
                    
                    
                    // スコープの返り値で推論
                    _ = hir.type.unify(blockScope.retType);
                }
                | Fn(args, body, bodyScope) => {
                    def fnType: Type.Fn = match (hir.type.unVar()) {
                        | it is Type.Fn => it
                        | _ => Type.Fn(args.Map(_ => Type.Var()), Type.Var())
                    }
                    
                    // インスタンスメソッド(最初の引数がthisなら)
                    when (args.Length > 0 && args.First().name == "this") {
                        def typeName = searchTypeScopeName(scope);
                        when (typeName.IsSome) {
                            fnType.args = scope.resolveType(typeName.Value) :: fnType.args.Tail;
                        }
                    }
                    
                    // 引数の型推論
                    foreach (i in Enumerable.Range(0, fnType.args.Count())) {
                        _ = bodyScope.resolveArgNth(i).Value.type.unify(fnType.args.Nth(i));
                    }
                    _ = bodyScope.retType.unify(fnType.ret);
                    typing(bodyScope, body, fnType.ret);
                    
                    _ = hir.type.unify(fnType);
                }
                | Id(name, _) as id => {
                    _ = id.type.unify(expected);
                    match (id.getSymbol(scope)) {
                        | Some(var) => {
                            _ = hir.type.unify(var.type);
                        }
                        | _ => hir.errors.Add(Error.UndefinedReference(name, expected))
                    }
                }
                | Member(expr, name) => {
                    typing(scope, expr, Type.Unknown());
                    
                    def ty = match (expr.type.pruned()) {
                        | Type.Define as it => {
                            def fieldsTypes = it.fields.Filter(fi => fi.name == name).Map(_.type);
                            def methodsTypes = it.methods.Filter(mt => mt.name == name).Map(m => match (m.fn.type.pruned()) {
                                | Type.Fn(args, ret) when args.Length > 0 => if (args.First().canUnify(it)) {
                                    // 最初の引数に自身を適用する
                                    if (args.Length == 1) ret else Type.Fn(args.Tail, ret)
                                } else {
                                    null // 最初の引数の型が違う
                                }
                                | _ => null // そもそも関数じゃない
                            }).Filter(t => t != null); // 合わなかった型を除く
                            def cand = fieldsTypes.Concat(methodsTypes).NToList();
                            if (cand.Length == 0)
                                Type.Error(TypeError.InferenceFailure($"Could not find field $name in $(it.name)."))
                            else
                                Type.OneOf(cand)
                        }
                        // TODO Native
                        | _ => Type.Unknown()
                    };
                    _ = hir.type.unify(ty);
                }
                | StaticMember(tyName, name) => {
                    mutable ty = scope.resolveType(tyName);
                    match (ty.pruned()) {
                        | Type.Define as cls => {
                            def es = cls.methods.Map(m => m.fn.type).Filter(_.canUnify(hir.type))
                                .Concat(cls.fields.Map(_.type).Filter(_.canUnify(hir.type)))
                                .NToList();
                            if (es.Length == 1) {
                                _ = hir.type.unify(es.First())
                            } else if (es.IsEmpty()) {
                                hir.type.errors.Add(TypeError.InferenceFailure($"Could not resolve $tyName::$name as $(hir.type.pruned())"))
                            } else {
                               _ = hir.type.unify(Type.OneOf(es))
                            }
                        }
                        | Type.Native(nt) => {
                            // TODO クラス変数
                            def overloads = nt.GetMethods().Filter(methodInfo => {
                                if (methodInfo.Name == name) {
                                    match (hir.type.pruned()) {
                                        | it is Type.Fn => it.canUnify(methodInfo.toFnType(scope))
                                        | _ => true
                                    }
                                } else {
                                    false
                                }
                            });
                            if (overloads.Length == 1) {
                                _ = hir.type.unify(overloads.First().toFnType(scope))
                            } else if (overloads.Length > 1) {
                                _ = hir.type.unify(Type.OneOf(overloads.Map(m => m.toFnType(scope))))
                            } else {
                                hir.type.errors.Add(TypeError.InferenceFailure($"Could not resolve $tyName::$name as $(hir.type.pruned())"))
                            }
                        }
                        | _ => hir.type.errors.Add(TypeError.Undefined(tyName))
                    }
                }
                | Apply(fn, args) => {
                    // 関数の型を特定したいので、先に引数の型を解析
                    foreach (arg in args) {
                        typing(scope, arg, Type.Unknown());
                    }
                    // 関数を解決
                    typing(scope, fn, Type.Fn(args.Map(_.type), Type.Var(expected)));
                    
                    // 関数の型から引数と返り値を推論
                    match (fn.type.unVar()) {
                        | Type.Fn(xs, y) when xs.Length == args.Length => {
                            foreach ((arg, x) in args.Zip(xs)) {
                                _ = arg.type.unify(x)
                            }
                            
                            _ = hir.type.unify(y)
                        }
                        | Type.Error => () // エラーならそれ以上推論しない
                        | t => fn.type.errors.Add(TypeError.InferenceFailure($"Could not infer $t as a function."))
                    }
                }
                | Switch(entries) => {
                    foreach (entry in entries) {
                        // 条件式をBoolとして型推論
                        typing(scope, entry.pred, Type.Bool);
                        // bodyスコープでこの式の型として型推論
                        typing(entry.bodyScope, entry.body, hir.type);
                    }
                }
            }
        }
        
        // 型の関係式をトップダウンで構築
        public typing(scope: Hir.Scope, hir: Hir.Stmt): void {
            match (hir) {
                | Hir.Stmt.Var(id, rhs, _) => {
                    typing(scope, rhs, Type.Unknown()); // TODO type hint
                    id.symbolCache = Some(scope.declareLocal(id.name, rhs.type)); // 右辺を処理してから変数宣言
                }
                | Hir.Stmt.Assign(id, rhs) => {
                    typing(scope, rhs, Type.Unknown());
                    // 右辺から左辺の型を推論
                    _ = id.type.unify(rhs.type);
                    match (id.getSymbol(scope)) {
                        | Some(dest) => {
                            _ = dest.type.unify(rhs.type)
                        }
                        | _ => hir.errors.Add(Hir.Error.UndefinedReference(id.name, rhs.type))
                    }
                }
                | Hir.Stmt.Expr(expr) => typing(scope, expr, Type.Unknown())
                | Hir.Stmt.Return(value) => {
                    typing(scope, value, Type.Unknown());
                    _ = scope.getRetType().Map(t => t.unify(value.type)) // 返り値でスコープの型を推論
                }
            }
        }
        
        searchTypeScopeName(scope: Hir.Scope): option[string] {
            match (scope) {
                | Hir.Scope.Type as t => Some(t.name)
                | _ => match (scope.getParent()) {
                    | Some(p) => searchTypeScopeName(p)
                    | _ => None()
                }
            }
        }
    }
    
    public module HirTypingExtensions {
        public static toFnType(this methodInfo: System.Reflection.MethodInfo, scope: Scope): Atla.Lang.Type.Fn {
            def pTypes = methodInfo.GetParameters().Map(p => p.ParameterType);
            def argTypes = if (pTypes.IsEmpty())
                [Type.Unit] // 引数がないときは代わりにUnitを引数とする
            else
                pTypes.Map(t => Type.Native(t)).ToNList();
            Atla.Lang.Type.Fn(argTypes, Type.Native(methodInfo.ReturnType));
        }
        
    }
}
