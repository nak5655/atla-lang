using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Atla.Lang.Hir
{
    public class Typing
    {
        public this() {
        }
        
        public typing(hir: Hir.Module): void {
            foreach (import in hir.imports) {
                // TODO: import atla module (non Native)
                hir.scope.declareType(import.dotted(), Hir.Type.Native(System.Type.GetType(import.dotted())))
                // TODO: short name (e.g. System.Type as Type)
            }
            
            // first, declare members
            foreach ((id, member) in hir.members.KeyValuePairs) {
                foreach (overload in member) {
                    hir.scope.declareVar(id, overload.type)
                }
            }
            // next, analyze the type hints.
            foreach ((_, member) in hir.members.KeyValuePairs) {
                foreach (overload in member) {
                    typing(hir.scope, overload, Type.Any());
                }
            }
        }
        
        // トップダウンで型を構築してボトムアップで型推論
        public typing(scope: Scope, hir: Hir.Expr, expected: Type): void {
            hir.type.specialize(hir.typeHint.resolve(scope));
            
            match (hir) {
                | Unit => hir.type.specialize(scope.globalScope().resolveType(Scope.unitTypeName)) // オーバーロード対策で念のためGlobalScopeで名前解決する
                | Int => hir.type.specialize(scope.globalScope().resolveType(Scope.intTypeName))
                | String => hir.type.specialize(scope.globalScope().resolveType(Scope.stringTypeName))
                | Block(blockScope, stmts) => {
                    foreach (stmt in stmts) {
                        typing(blockScope, stmt);
                    }
                    
                    // スコープの返り値で推論
                    hir.type.generalize(blockScope.retType);
                }
                | Fn(args, body, bodyScope) => {
                    def argTypes = args.Map(arg => arg.typeHint.resolve(scope));
                    typing(bodyScope, body, Type.Any());
                    
                    hir.type.generalize(Type.Fn(argTypes, body.type));
                }
                | Id(name) => {
                    hir.type.specialize(scope.resolveVar(name, expected));
                }
                | Member(expr, name) => typing(scope, expr, Type.Any())
                | Apply(fn, args) => {
                    def argTypes = match (fn.type.unVar()) {
                        | Type.Fn(ts, _) when args.Length == ts.Length => ts
                        | _ => args.Map(_ => Type.Any())
                    }
                    foreach ((arg, t) in args.Zip(argTypes)) {
                        typing(scope, arg, t);
                    }
                    
                    def fnType = Type.Fn(args.Map(_.type), expected);
                    typing(scope, fn, fnType);
                }
            }
        }
        
        // 型の関係式をトップダウンで構築
        public typing(scope: Hir.Scope, hir: Hir.Stmt): void {
            match (hir) {
                | Hir.Stmt.Let(name, rhs) => {
                    typing(scope, rhs, Type.Any()); // TODO type hint
                    scope.declareVar(name, rhs.type); // 右辺を処理してから変数宣言
                }
                | Hir.Stmt.Assign(name, rhs) => {
                    typing(scope, rhs, Type.Any());
                    // 右辺から左辺の型を推論
                    def destType = scope.resolveVar(name, Type.Any());
                    _ = destType.specialize(rhs.type)
                }
                | Hir.Stmt.Expr(expr) => typing(scope, expr, Type.Any())
                | Hir.Stmt.Return(value) => {
                    typing(scope, value, Type.Any());
                    scope.retType.generalize(value.type) // 返り値でスコープの型を推論
                }
            }
        }
    }
}
