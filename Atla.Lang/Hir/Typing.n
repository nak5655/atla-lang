using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Atla.Lang.Hir
{
    public class Typing
    {
        public this() {
        }
        
        public typing(hir: Hir.Module): void {
            foreach (import in hir.imports) {
                // TODO: import atla module (non Native)
                hir.scope.declareType(import.dotted(), Hir.Type.Native(System.Type.GetType(import.dotted())))
                // TODO: short name (e.g. System.Type as Type)
            }
            
            // first, declare members
            foreach ((id, member) in hir.members.KeyValuePairs) {
                foreach (overload in member) {
                    hir.scope.declareVar(id, overload.typeVar)
                }
            }
            // next, analyze the type hints.
            foreach ((_, member) in hir.members.KeyValuePairs) {
                foreach (overload in member) {
                    analyze(hir.scope, overload);
                }
            }
            // next, infer the types.
            foreach ((_, member) in hir.members.KeyValuePairs) {
                foreach (overload in member) {
                    infer(hir.scope, overload);
                }
            }
        }
        
        // 型の関係式をトップダウンで構築
        public analyze(scope: Scope, hir: Hir.Expr): void {
            match (hir) {
                | Unit => hir.typeVar.addHint(Hir.TypeHint.Name(scope.globalScope(), Scope.unitTypeName)) // オーバーロード対策で念のためGlobalScopeで名前解決する
                | Int => hir.typeVar.addHint(Hir.TypeHint.Name(scope.globalScope(), Scope.intTypeName))
                | String => hir.typeVar.addHint(Hir.TypeHint.Name(scope.globalScope(), Scope.stringTypeName))
                | Block(blockScope, stmts) => {
                    blockScope.retTypeVar.addHint(Hir.TypeHint.BehaveAs(hir.typeVar));
                    foreach (stmt in stmts) {
                        analyze(blockScope, stmt);
                    }
                }
                | Fn(args, body, bodyScope) => {
                    def fnType = Hir.TypeHint.Fn(args.Map(_.typeVar), body.typeVar);
                    hir.typeVar.addHint(fnType);
                    body.typeVar.addHint(Hir.TypeHint.BehaveAs(fnType.ret));
                    
                    analyze(bodyScope, body);
                }
                | Id(name) => {
                    def hint = Hir.TypeHint.BehaveAsOneOf(scope.resolveVar(name, hir.typeVar).ToNList());
                    _ = hint.addSpan(hir.span);
                    hir.typeVar.addHint(hint);
                }
                | Member(expr, _) => analyze(scope, expr)
                | Apply(fn, args) => {
                    analyze(scope, fn);
                    foreach (arg in args) {
                        analyze(scope, arg);
                    }
                }
            }
        }
        
        // 型をボトムアップで解決
        public infer(scope: Scope, hir: Hir.Expr): void {
            match (hir) {
                | Unit => hir.typeVar.resolveAs(scope.globalScope().resolveType(Scope.unitTypeName).Value)
                | Int => hir.typeVar.resolveAs(scope.globalScope().resolveType(Scope.intTypeName).Value)
                | String => hir.typeVar.resolveAs(scope.globalScope().resolveType(Scope.stringTypeName).Value)
                | Block(blockScope, stmts) => {
                    foreach (stmt in stmts) {
                        infer(blockScope, stmt)
                    }
                    
                    // スコープの返り値で推論
                    hir.typeVar.genHints.Add(blockScope.retTypeVar);
                    _ = hir.typeVar.genInfer();
                }
                | Fn(_, body, bodyScope) => {
                    infer(bodyScope, body);
                }
                | Id => {}
                | Member(expr, _) => {
                    infer(scope, expr)
                }
                | Apply(fn, args) => {
                    infer(scope, fn);
                    foreach (arg in args) {
                        infer(scope, arg);
                    }
                }
            }
            _ = hir.typeVar.infer()
        }
        
        // 型の関係式をトップダウンで構築
        public analyze(scope: Hir.Scope, hir: Hir.Stmt): void {
            match (hir) {
                | Hir.Stmt.Let(name, rhs) => {
                    analyze(scope, rhs);
                    scope.declareVar(name, rhs.typeVar); // 右辺を処理してから変数宣言
                }
                | Hir.Stmt.Assign(name, rhs) => {
                    analyze(scope, rhs);
                    
                    def vars = scope.resolveVar(name, rhs.typeVar);
                    rhs.typeVar.addHint(Hir.TypeHint.BehaveAsOneOf(vars.ToNList()));
                }
                | Hir.Stmt.Expr(expr) => analyze(scope, expr)
                | Hir.Stmt.Return(value) => {
                    value.typeVar.addHint(TypeHint.BehaveAs(scope.retTypeVar));
                    analyze(scope, value)
                }
            }
        }
        
        // 型をボトムアップで解決
        public infer(scope: Hir.Scope, hir: Hir.Stmt): void {
            match (hir) {
                | Hir.Stmt.Let(_, rhs) => {
                    infer(scope, rhs);
                }
                | Hir.Stmt.Assign(_, rhs) => {
                    infer(scope, rhs);
                }
                | Hir.Stmt.Expr(expr) => infer(scope, expr)
                | Hir.Stmt.Return(value) => {
                    infer(scope, value);
                    
                    scope.retTypeVar.genHints.Add(value.typeVar); // 右辺の型が確定したら、スコープの返り値の型を推論
                }
            }
        }
    }
}
