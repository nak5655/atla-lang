using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

using Atla.Lang;
using Atla.Lang.Mir;

namespace Atla.Lang.Hir
{
    // a.k.a SymbolTable or Environment
    public variant Scope: Atla.Lang.TypeScope {
        | Global {
            __dummy: int = 0;
            
            public this() {
                typeTable.Add(Type.UNIT_NAME, Type.Native(typeof(void)));
                typeTable.Add(Type.BOOL_NAME, Type.Native(typeof(bool)));
                typeTable.Add(Type.INT_NAME, Type.Native(typeof(int)));
                typeTable.Add(Type.STRING_NAME, Type.Native(typeof(string)));
            
                def tint = Type.Native(typeof(int));
                def tbool = Type.Native(typeof(bool));
                varTable.Add(Symbol("+", Type.Fn([tint, tint], tint), SymbolKind.InlineMethod(Proc.DstArg2((dst, arg0, arg1) => [
                    Mir.Ins.Add(dst, arg0, arg1),
                ]))));
                varTable.Add(Symbol("-", Type.Fn([tint, tint], tint), SymbolKind.InlineMethod(Proc.DstArg2((dst, arg0, arg1) => [
                    Mir.Ins.Sub(dst, arg0, arg1),
                ]))));
                varTable.Add(Symbol("||", Type.Fn([tbool, tbool], tbool), SymbolKind.InlineMethod(Proc.DstArg2((dst, arg0, arg1) => [
                    Mir.Ins.Or(dst, arg0, arg1),
                ]))));
                varTable.Add(Symbol("==", Type.Fn([tint, tint], tbool), SymbolKind.InlineMethod(Proc.DstArg2((dst, arg0, arg1) => [
                    Mir.Ins.Eq(dst, arg0, arg1),
                ]))));
            }
        }
        | Assembly {
            public parent: Scope.Global;
            public name: string;
        }
        | Module {
            public parent: Scope;
            public name: string;
        }
        | Fn { // TODO この時点でFrameにしてもいいかも
            public parent: Scope;
            // TODO name あってもいいかも
            public retType: Type;
            
            public this(parent: Scope) {
                this.parent = parent;
                retType = Type.Var();
            }
            
            public resolveArgNth(n: int): option[Symbol] {
                def args = varTable.Filter(_.isArg()).NToList();
                if (0 <= n && n < args.Length)
                    Some(args.Nth(n))
                else
                    None()
            }
            
            public declareArg(id: string, type: Type): void {
                varTable.Add(Symbol(id, type, SymbolKind.Arg()));
            }
        }
        | Block {
            public parent: Scope;
            public name: option[string];
            public retType: Type;
            
            public mutable endLabel: Mir.Ins.Label;
            public mutable retSymbol: Symbol;
            
            public this(parent: Scope) {
                this.parent = parent;
                this.name = None();
                retType = Type.Var();
                endLabel = Mir.Ins.Label();
            }
            
            public this(parent: Scope, name: option[string]) {
                this.parent = parent;
                this.name = name;
                retType = Type.Var();
                endLabel = Mir.Ins.Label();
            } 
        }
        
        public varTable: List[Symbol] = List();
        typeTable: Hashtable[string, Type] = Hashtable();
        implTable: Hashtable[string, Impl] = Hashtable();
        
        public parent(): option[Scope] {
            match (this) {
                | Global => None()
                | Module(p, _) => Some(p)
                | it is Fn => Some(it.parent)
                | it is Block => Some(it.parent)
            }
        }
        
        public name(): option[string] {
            match (this) {
                | Global => None()
                | Module(_, n) => Some(n)
                | Fn => None()
                | it is Block => it.name
            }
        }
        
        public retType(): option[Type] {
            match (this) {
                | Global => None()
                | Module => None()
                | it is Fn => Some(it.retType)
                | it is Block => Some(it.retType)
            }
        }
        
        public path(): string {
            def p = parent().Map(_.path()).WithDefault("");
            
            match (name()) {
                | Some(s) => if (p.Length > 0) $"$p::$s" else s
                | None => p
            }
        }
        
        public fullName(name: string): string {
            def p = path();
            if (p.Length > 0) $"$p::$name" else name
        }
        
        // TODO 経路圧縮
        public globalScope(): Scope {
            match (parent()) {
                | Some(p) => p.globalScope()
                | _ => this
            }
        }
        
        public declareType(id: string, type: Type): void {
            // TODO 重複エラー
            typeTable.Add(id, type)
        }
        
        public resolveType(id: string): Type {
            if (typeTable.ContainsKey(id)) {
                typeTable.Get(id).Value
            } else {
                match (parent()) {
                    | Some(p) => p.resolveType(id)
                    | _ => Type.Error(TypeError.Undefined(id))
                }
            }
        }
        
        public declareLocal(id: string, type: Type): void {
            varTable.Add(Symbol(id, type, SymbolKind.Local()));
        }
        
        // 名前解決での優先順で返す（内側のスコープを優先）
        public resolveVar(id: string, type: Type): option[Symbol] {
            def syms = varTable.Filter(s => s.name == id && type.canUnify(s.type)) : list[Symbol];
            
            if (syms.Length == 0) {
                match (parent()) {
                    | Some(s) => s.resolveVar(id, type)
                    | _ => None()
                }
            } else if (syms.Length == 1) {
                Some(syms.First())
            } else {
                // 複数の宣言にマッチしてもエラー
                def e = Type.Var(Type.Error(TypeError.Ambiguous(syms.Map(_.type))));
                def sym = Symbol(id, e, SymbolKind.Local());
                varTable.Add(sym);
                Some(sym) // エラーのシンボルとして返す
            }
        }
    }
}
