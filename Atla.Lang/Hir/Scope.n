using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Atla.Lang.Hir
{
    // a.k.a SymbolTable or Environment
    public class Scope {
        parent: option[Scope] = None();
        varTable: Hashtable[string, List[Type.Var]] = Hashtable();
        typeTable: Hashtable[string, Type] = Hashtable();
        implTable: Hashtable[string, Impl] = Hashtable();
        public retType: Type = Type.Var();
        
        // Primery Types
        public static unitTypeName: string = "Unit";
        public static intTypeName: string = "Int";
        public static stringTypeName: string = "String";
        
        public this(parent: Scope) {
            this.parent = Some(parent);
        }
        
        public this() {
            // Global Scope
            typeTable.Add(unitTypeName, Type.Native(typeof(void)));
            typeTable.Add(intTypeName, Type.Native(typeof(int)));
            typeTable.Add(stringTypeName, Type.Native(typeof(string)));
        }
        
        // TODO 経路圧縮
        public globalScope(): Scope {
            match (parent) {
                | Some(p) => p.globalScope()
                | _ => this
            }
        }
        
        public declareType(id: string, type: Type): void {
            typeTable.Add(id, type)
        }
        
        public resolveType(id: string): Type {
            if (typeTable.ContainsKey(id)) {
                typeTable.Get(id).Value
            } else if (parent.IsSome) {
                parent.Value.resolveType(id)
            } else {
                Type.Error(Error.UndefinedType(id))
            }
        }
        
        public declareVar(id: string, type: Type.Var): void {
            if (varTable.ContainsKey(id)) {
                def types = varTable.Get(id).Value;
                types.Add(type);
            } else {
                varTable.Set(id, [type].ToList());
            }
        }
        
        // 名前解決での優先順で返す（内側のスコープを優先）
        public resolveVar(id: string, type: Hir.Type): Hir.Type {
            when (varTable.ContainsKey(id)) {
                def ts = varTable.Get(id).Value.Filter(t => type.canSpecialize(t));
                return if (ts.Length == 0) {
                    match (parent) {
                        | Some(s) => s.resolveVar(id, type)
                        | _ => Type.Error(Error.UndefinedReference(id, type))
                    }
                } else if (ts.Length == 1) {
                    ts.First()
                } else {
                    Type.Error(Error.AmbiguousType(ts))
                }
            }
            
            match (parent) {
                | Some(s) => s.resolveVar(id, type)
                | _ => Type.Error(Error.UndefinedReference(id, type))
            }
        }
    }
}
