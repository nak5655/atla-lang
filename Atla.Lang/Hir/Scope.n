using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;

using System;
using System.Collections.Generic;
using System.Linq;

using Atla.Lang;

namespace Atla.Lang.Hir
{
    // a.k.a SymbolTable or Environment
    public class Scope: Atla.Lang.TypeScope {
        parent: option[Scope] = None();
        varTable: Hashtable[string, List[Type]] = Hashtable();
        typeTable: Hashtable[string, Type] = Hashtable();
        implTable: Hashtable[string, Impl] = Hashtable();
        public retType: Type = Type.Var();
        
        public this(parent: Scope) {
            this.parent = Some(parent);
        }
        
        public this() {
            // Global Scope
            typeTable.Add(Type.UNIT_NAME, Type.Native(typeof(void)));
            typeTable.Add(Type.INT_NAME, Type.Native(typeof(int)));
            typeTable.Add(Type.STRING_NAME, Type.Native(typeof(string)));
            
            def tint = Type.Native(typeof(int));
            varTable.Add("+", [Type.Fn([tint, tint], tint)].ToList());
        }
        
        // TODO 経路圧縮
        public globalScope(): Scope {
            match (parent) {
                | Some(p) => p.globalScope()
                | _ => this
            }
        }
        
        public declareType(id: string, type: Type): void {
            // TODO 重複エラー
            typeTable.Add(id, type)
        }
        
        public resolveType(id: string): Type {
            if (typeTable.ContainsKey(id)) {
                typeTable.Get(id).Value
            } else if (parent.IsSome) {
                parent.Value.resolveType(id)
            } else {
                Type.Error(TypeError.Undefined(id))
            }
        }
        
        public declareVar(id: string, type: Type): void {
            if (varTable.ContainsKey(id)) {
                def types = varTable.Get(id).Value;
                types.Add(type);
            } else {
                varTable.Set(id, [type].ToList());
            }
        }
        
        // 名前解決での優先順で返す（内側のスコープを優先）
        public resolveVar(id: string, type: Type): Type {
            when (varTable.ContainsKey(id)) {
                def ts = varTable.Get(id).Value.Filter(t => type.canUnify(t)) : list[Type];
                return if (ts.Length == 0) {
                    match (parent) {
                        | Some(s) => s.resolveVar(id, type)
                        | _ => {
                            // 未定義の変数は新たに定義したうえでエラーとして返す
                            def e = Type.Var(Type.Error(TypeError.Undefined(id)));
                            declareVar(id, e);
                            e
                        }
                    }
                } else if (ts.Length == 1) {
                    ts.First()
                } else {
                    // 未定義の変数は新たに定義したうえでエラーとして返す
                    def e = Type.Var(Type.Error(TypeError.Ambiguous(ts.Map(_ : Type))));
                    declareVar(id, e);
                    e
                }
            }
            
            match (parent) {
                | Some(s) => s.resolveVar(id, type)
                | _ => {
                    // 未定義の変数は新たに定義したうえでエラーとして返す
                    def e = Type.Var(Type.Error(TypeError.Undefined(id)));
                    declareVar(id, e);
                    e
                }
            }
        }
    }
}
