using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

using Atla;
using Atla.Lang;
using Atla.Lang.Parse;

namespace Atla.Lang.Ast
{
    public variant Pattern: HasSpan[Pattern] {
        | Any
        | Int { value: int }
    }
    
    [Record]
    public variant MatchEntry: HasSpan[MatchEntry] {
        | Case { pattern: Pattern; expr: Expr; }
        | Error { reason: string }
    }
    
    [Record]
    public class FnArg: HasSpan[FnArg] {
        public name: string;
        public typeHint: TypeHint;
    }
    
    public variant Expr: HasSpan[Expr] {
        | Unit
        | Int { value: int }
        | String { value: string }
        | Id { value: string }
        | Block { stmts: list[Stmt] }
        | Fn { args: list[FnArg]; body: Expr }
        | Member { obj: Expr; member: string }
        | StaticMember { objName: string; member: string }
        | Apply { fn: Expr; args: list[Expr] }
        | Match { expr: Expr; entries: list[MatchEntry] }
        | Error { reason: string }
        
        public typeHint: option[TypeHint] = None();
    }
    
    public variant Stmt: HasSpan[Stmt] {
        | Let { name: string; rhs: Ast.Expr }
        | Assign { name: string; rhs: Ast.Expr }
        | Expr { expr: Ast.Expr }
        | Ret { expr: Ast.Expr }
    }
    
    public variant ClassItem: HasSpan[ClassItem] {
        | Field { name: string; typeHint: TypeHint; mut: bool; init: option[Expr] }
        | Method { name: string; args: list[FnArg]; body: Expr }
        | Error { reason: string }
    }
    
    public variant Decl: HasSpan[Decl] {
        | Class { name: string; items: list[ClassItem] }
        | Fn { name: string; args: list[FnArg]; ret: TypeHint; body: Ast.Expr }
        | Import { path: list[string] }
        | Error { reason: string }
        
        public scanErrors(): IEnumerable[(string * Span)] {
            match (this) {
                | Error(s) => [(s, this.span)]
                // TODO
                | _ => []
            }
        }
    }
    
    [Record]
    public class Module: HasSpan[Module] {
        public decls: list[Decl];
        
        public scanErrors(): IEnumerable[(string * Span)] {
            decls.SelectMany(_.scanErrors())
        }
    }
}
