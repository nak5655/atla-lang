using Nemerle;
using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Atla;

namespace Atla.Lang.Ast
{
    // 脱糖
    // 意味解析 (スコープ構築, 型変数にタイプヒントを追加)
    class Trans
    {
        public trans(scope: Hir.Scope, type: Ast.Type): Hir.TypeHint {
            def hint = match (type) {
                | Ast.Type.Unit => Hir.TypeHint.Name(scope.globalScope(), Hir.Scope.unitTypeName)
                | Ast.Type.Fn(args, ret) => Hir.TypeHint.Fn(args.Map(a => Hir.TypeVar(trans(scope, a))), Hir.TypeVar(trans(scope, ret)))
                | Ast.Type.Id(value) => Hir.TypeHint.Name(scope, value)
                | Ast.Type.Generics(_base, _params) => Hir.TypeHint.Generics(Hir.TypeVar(trans(scope, _base)), _params.Map(p => Hir.TypeVar(trans(scope, p))))
            };
            hint.addSpan(type.span)
        }
        
        public trans(scope: Hir.Scope, ast: Ast.Stmt): Hir.Stmt {
            def stmt: Hir.Stmt = match (ast) {
                | Ast.Stmt.Expr(expr) => Hir.Stmt.Expr(trans(scope, expr))
                | Ast.Stmt.Let(name, expr) => {
                    def rhs = trans(scope, expr);
                    def let = Hir.Stmt.Let(name, rhs);
                    scope.declareVar(name, rhs.typeVar);
                    let
                }
                | Ast.Stmt.Ret(expr) => Hir.Stmt.Return(trans(scope, expr))
            };
            stmt.addSpan(ast.span)
        }
        
        public trans(scope: Hir.Scope, ast: Ast.Expr): Hir.Expr {
            def expr: Hir.Expr = match (ast) {
                | Ast.Expr.Unit => Hir.Expr.Unit()
                | Ast.Expr.Int(value) => Hir.Expr.Int(value)
                | Ast.Expr.String(value) => Hir.Expr.String(value)
                | Ast.Expr.Block(stmts) => {
                    def block = Hir.Expr.Block(scope);
                    block.stmts = stmts.Map(s => trans(block.scope, s)).ToList();
                    block
                }
                | Ast.Expr.Fn(args, body) => {
                    def fnType = Hir.TypeHint.Fn(args.Map(a => Hir.TypeVar(trans(scope, a.type))), Hir.TypeVar());
                    def fn = Hir.Expr.Fn(scope, args.Map(_.name));
                    fn.typeVar.addHint(fnType);
                    fn.body = trans(fn.scope, body);
                    fn.body.typeVar.addHint(Hir.TypeHint.BehaveAs(fnType.ret));
                    fn
                }
                | Ast.Expr.Id(value) => Hir.Expr.Id(value)
                | Ast.Expr.Member(expr, member) => Hir.Expr.Member(trans(scope, expr), member)
                | Ast.Expr.Apply(fn, args) => Hir.Expr.Apply(trans(scope, fn), args.Map(e => trans(scope, e)))
            }
            expr.addSpan(ast.span)
        }
        
        public declare(mod: Hir.Module, ast: Ast.Decl): void {
            match (ast) {
                | Ast.Decl.Import(path) => mod.import(path)
                | Ast.Decl.Fn(name, args, ret, body) => {
                    def fnType = Hir.TypeHint.Fn(args.Map(a => Hir.TypeVar(trans(mod.scope, a.type))), Hir.TypeVar(trans(mod.scope, ret)));
                    _ = fnType.addSpan(args.Map(_.span) + [ret.span]);
                    
                    def fn = Hir.Expr.Fn(mod.scope, args.Map(_.name));
                    fn.typeVar.addHint(fnType);
                    mod.declareFn(name, fn);
                    fn.body = trans(fn.scope, body); // 関数宣言でスコープを作ってから本体を定義
                    
                    def retType = Hir.TypeHint.BehaveAs(fnType.ret);
                    _ = retType.addSpan(ret.span);
                    fn.body.typeVar.addHint(retType);
                }
            }
        }
        
        public trans(ast: Ast.Module, name: string): Hir.Module {
            def mod = Hir.Module(name);
            foreach (decl in ast.decls) {
                declare(mod, decl);
            }
            mod
        }
    }
}
