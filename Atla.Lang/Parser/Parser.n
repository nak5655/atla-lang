using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

using Atla.Lang;
using Atla.Lang.Parse;
using Atla.Lang.Ast;

namespace Atla.Lang.Parser
{
    public class TokenInput: Input[Token] {
        data: list[Token];
        index: int;
        
        public this(data: list[Token], index: int) {
            this.data = data.Filter(t => !(t is Token.Comment)); // remove comments
            this.index = index;
        }
        
        public get(): option[Token] {
            if (0 <= index && index < data.Length)
                Some(data.ElementAt(index))
            else
                None()
        }
        
        public position(): Span {
            match (get()) {
                | Some(t) => t.span
                | _ when index >= data.Length && data.Length > 0 => {
                    def p = data.Last().span.hi;
                    Span(p, Position(p.lines, p.line, p.col + 1, p.index + 1)) // end of data
                }
                | _ => Span.zero()
            }
        }
        
        public next(): Input[Token] {
            TokenInput(data, index + 1)
        }
    }
    
    public class BlockInput: Input[Token] {
        public parent: Input[Token];
        openBy: Token;
        openAt: Position;
        
        public this(parent: Input[Token], openBy: Token) {
            this.parent = parent;
            this.openBy = openBy;
            
            // 行頭をブロック開始位置とする
            def line = openBy.span.lo.line;
            def col = openBy.span.lo.lines.Nth(line).TakeWhile(_ == ' ').Count();
            def index = openBy.span.lo.index - (openBy.span.lo.col - col);
            this.openAt = Position(openBy.span.lo.lines, line, col, index);
        }
        
        public get(): option[Token] {
            match (parent.get()) {
                | Some(t) => {
                    if (t.span.lo.line == openAt.line && t.span.lo.col <= openAt.col) // openしたTokenも含める
                        Some(t)
                    else if (t.span.lo.col <= openAt.col)
                        None()
                    else
                        Some(t)
                }
                | _ => None()
            }
        }
        
        public position(): Span {
            parent.position() :> Span
        }
        
        public next(): Input[Token] {
            BlockInput(parent.next(), openBy)
        }
    }
    
    public variant OnceResult[I, A] {
        | Ok { value: A }
        | Ng { failure: Result[I, A] }
    }
    
    public class OffsideParserEnv: ParserEnv[Token] {
        
    }
    
    public class Parser: OffsideParserEnv
    {
        public typeHint: ParserRef[Token, TypeHint] = ParserRef();
        public pattern: ParserRef[Token, Pattern] = ParserRef();
        public expr: ParserRef[Token, Expr] = ParserRef();
        public stmt: ParserRef[Token, Stmt] = ParserRef();
        public decl: ParserRef[Token, Decl] = ParserRef();
        public mod: Parser[Token, Ast.Module];
        
        public this() {
            def tid: Parser[Token, Token.Id] = satisfy("id", _ is Token.Id).map(_ :> Token.Id);
            def infixOp(precedence: int): Parser[Token, Token.InfixOp] {
                satisfy("infixOp", t => t is Token.InfixOp && (t :> Token.InfixOp).precedence == precedence).map(_ :> Token.InfixOp)
            }
            
            // TypeHint
            {
                def typeHintFactor: Parser[Token, TypeHint] = tid.map(a => TypeHint.Name(a.value).exSpan(a));
                def typeHintParen: Parser[Token, TypeHint] = delim("(")._and(typeHintFactor.optional().map(mt => {
                    match (mt) {
                        | Some(t) => t
                        | _ => TypeHint.Unit()
                    }
                }))._and(delim(")")).map((ab, c) => ab[1].exSpan([ab[0], c]));
                def typeHintTerm = typeHintParen._or(typeHintFactor);
                
                typeHint.impl = typeHintTerm.many1().map(ts => {
                    if (ts.Length == 1)
                        ts.Head
                    else
                        TypeHint.Generics(ts.Head, ts.Tail)
                });
            }
            
            // Pattern
            {
                def int = satisfy("int", _ is Token.Int).map(t => Pattern.Int((t :> Token.Int).value).exSpan([t]));
                def any = satisfy("any", t => t is Token.Id && (t :> Token.Id).value == "_").map(t => Pattern.Any().exSpan([t])); // delim("_")では無いので注意
                pattern.impl = int._or(any);
            }
            
            // Expr
            {
                def id = log("expr_id", tid.map(t => Expr.Id(t.value).exSpan(t)));
                def unit = log("expr_unit", delim("(")._and(delim(")")).map((a, b) => Expr.Unit().exSpan([a, b])));
                def int = log("expr_int", satisfy("int", _ is Token.Int).map(t => Expr.Int((t :> Token.Int).value).exSpan(t)));
                def str = log("expr_string", satisfy("string", _ is Token.String).map(t => Expr.String((t :> Token.String).value).exSpan(t)));
                def paren = log("expr_paren", delim("(")._andR(expr)._andL(delim(")")));
                def blockExpr = log("do", delim("do")._and(
                    stmt.many1().map(ss => Expr.Block(ss).exSpan(ss)).onceExpr()
                ).map((a, b) => b.exSpan(a)));

                def matchEntry = log("match_entry", delim("|")._and(pattern._andL(delim("=>"))._and(expr).map((p, e) => {
                    MatchEntry.Case(p, e).exSpan([p.span, e.span])
                }).onceMatchEntry()).map((a, b) => b.exSpan(a)).consumeBlock());
                def matchExpr: Parser[Token, Expr] = log("match", delim("match")._and(
                    expr._and(matchEntry.many1()).map((e, cs) => {
                        Expr.Match(e, cs).exSpan(e.span :: cs.Map(_.span))
                    }).onceExpr()
                ).map((a, b) => b.exSpan(a)).consumeBlock());
                
                def factor = str._or(matchExpr)._or(blockExpr)._or(id)._or(int)._or(unit)._or(paren);
            
                // メンバーアクセス
                def member = log("expr_member", factor._andL(delim("."))._and(tid).map((a, b) => Expr.Member(a, b.value).exSpan([a.span, b.span])));
                def staticMember = log("expr_static", tid._andL(delim("::"))._and(tid).map((a, b) => Expr.StaticMember(a.value, b.value).exSpan([a.span, b.span])));
                def term1 = staticMember._or(member)._or(factor);
                
                // 呼び出し式
                def term2 = log("expr_apply", term1.many1().map(es => {
                    if (es.Length == 1)
                        es.First()
                    else
                        Expr.Apply(es.First(), es.Tail).exSpan(es)
                }));
                
                // 二項演算
                // 優先順位と逆順なので注意(term3がpreced6, term6がpreced3になる)
                def term6 = Enumerable.Range(3, 4).Reverse().Map(i => infixOp(i)).Fold(term2, (op, acc) => acc._and(op._and(acc).optional()).map((a, m_op_b) => {
                    match (m_op_b) {
                        | Some(op_b) => {
                            def op = op_b[0];
                            def b = op_b[1];
                            def fn = Expr.Id(op.value).addSpan(op.span);
                            Expr.Apply(fn, [a, b]).addSpan([a.span, b.span])
                        }
                        | _ => a
                    }
                }));
            
                expr.impl = term6.inlineBlock();
            }
            
            // Stmt
            {
                def letStmt = log("stmt_let", delim("let")._and(tid._andL(delim("="))._and(expr).map((id, e) => {
                    Stmt.Let(id.value, e).exSpan([id.span, e.span])
                }).onceStmt()).map((a, b) => b.exSpan(a)));
                def exprStmt = log("stmt_expr", expr.map(e => Stmt.Expr(e).exSpan(e)));
                def retStmt = log("stmt_return", delim("return")._and(expr.optional()).map((a, b) => {
                    def ret = Stmt.Ret(b.WithDefault(Expr.Unit())).exSpan(a);
                    if (b.IsSome) ret.exSpan(b.Value) else ret
                }));
                stmt.impl = letStmt._or(retStmt)._or(exprStmt).onceStmt().consumeBlock();
            }
            
            // Decls
            {
                def fnArg: Parser[Token, FnArg] = log("decl_fn_arg", delim("(")._andR(tid)._andL(delim(":"))._and(typeHint)._andL(delim(")")).map((a, b) => {
                    FnArg(a.value, b).exSpan([a.span, b.span])
                }));
                def fnArgs: Parser[Token, list[FnArg]] = fnArg.many1();
                def fnDecl: Parser[Token, Decl] = log("decl_fn", delim("fn")._and(tid._and(fnArgs)._andL(delim(":"))._and(typeHint)._andL(delim("="))._and(expr).map((n_rs_r, c) => {
                        def n = n_rs_r[0][0];
                        def rs = n_rs_r[0][1];
                        def r = n_rs_r[1];
                        Decl.Fn(n.value, rs, r, c).exSpan([n.span, c.span])
                    })._andL(eoi()).onceDecl()
                ).map((a, b) => b.exSpan(a)));
            
                def classValField: Parser[Token, ClassItem] = delim("val")._and(tid._andL(delim(":"))._and(typeHint)._and(delim("=")._andR(expr).optional()).map((s_t, e) => {
                    def (s, t) = s_t: Token.Id * TypeHint;
                    ClassItem.Field(s.value, t, false, e)
                })).map((a, b) => b.exSpan(a));
                def classVarField: Parser[Token, ClassItem] = delim("var")._and(tid._andL(delim(":"))._and(typeHint)._and(delim("=")._andR(expr).optional()).map((s_t, e) => {
                    def (s, t) = s_t: Token.Id * TypeHint;
                    ClassItem.Field(s.value, t, true, e)
                })).map((a, b) => b.exSpan(a));
                def classMethod: Parser[Token, ClassItem] = fnDecl.map(d => {
                    def ci = match (d) {
                        | Decl.Fn as f => ClassItem.Method(f.name, f.args, f.body)
                        | Decl.Error(reason) => ClassItem.Error(reason)
                    }
                    ci.exSpan(d)
                });
                def classItem = classValField._or(classVarField)._or(classMethod);
                def classDecl = delim("class")._and(
                    tid._and(classItem.many()).map((a, items) => {
                        Decl.Class(a.value, items).exSpan(a.span :: items.Map(i => i.span).LastN(1))
                    })._andL(eoi()).onceDecl()
                ).map((a, b) => b.exSpan(a));
            
                def importDecl = log("import", delim("import")._and(
                    tid._and(delim("::")._andR(tid).many()).map((x, xs) => {
                        def path = x.value :: xs.Map(t => t.value);
                        if (xs.Length > 1)
                            Decl.Import(path).exSpan((x :: xs.LastN(1)).Map(t => t))
                        else
                            Decl.Import(path).exSpan(x)
                    })._andL(eoi()).onceDecl()
                ).map((a, b) => b.exSpan(a)));
            
                decl.impl = importDecl._or(classDecl)._or(fnDecl).consumeBlock();
            }
            
            mod = decl.many().map(ds => {
                Ast.Module(ds).exSpan(ds)
            })._andL(eoi());
        }
        
        delim(s: string): Parser[Token, Token] {
            satisfy($"delimiter $s", t => {
                match (t) {
                    | Token.Delim(ts) when (s == ts) => true
                    | _ => false
                }
            })
        }
    }
    
    public module ParserExtensions {
        public onceExpr(this p: Parser[Token, Expr]): Parser[Token, Expr] {
            p.skipFail(ret => {
                def failure = ret :> Result[Token, Expr].Failure; // always it is failure
                def ret = Expr.Error(failure.reason);
                ret.span = failure.failAt.position() :> Span;
                ret
            })
        }
        
        public onceStmt(this p: Parser[Token, Stmt]): Parser[Token, Stmt] {
            p.skipFail(ret => {
                def failure = ret :> Result[Token, Stmt].Failure; // always it is failure
                def ret = Stmt.Error(failure.reason);
                ret.span = failure.failAt.position() :> Span;
                ret
            })
        }
        
        public onceDecl(this p: Parser[Token, Decl]): Parser[Token, Decl] {
            p.skipFail(ret => {
                def failure = ret :> Result[Token, Decl].Failure; // always it is failure
                def ret = Decl.Error(failure.reason);
                ret.span = failure.failAt.position() :> Span;
                ret
            })
        }
        
        public onceClassItem(this p: Parser[Token, ClassItem]): Parser[Token, ClassItem] {
            p.skipFail(ret => {
                def failure = ret :> Result[Token, ClassItem].Failure; // always it is failure
                def ret = ClassItem.Error(failure.reason);
                ret.span = failure.failAt.position() :> Span;
                ret
            })
        }
        
        public onceMatchEntry(this p: Parser[Token, MatchEntry]): Parser[Token, MatchEntry] {
            p.skipFail(ret => {
                def failure = ret :> Result[Token, MatchEntry].Failure; // always it is failure
                def ret = MatchEntry.Error(failure.reason);
                ret.span = failure.failAt.position() :> Span;
                ret
            })
        }
        
        public exSpan[T](this ast: T, span: Span): T where T: HasSpan[T] {
            ast.addSpan(span)
        }
        
        public exSpan[T](this ast: T, token: Token): T where T: HasSpan[T] {
            ast.exSpan(token.span)
        }
        
        public exSpan[T, S](this ast: T, s: S): T where T: HasSpan[T] where S: HasSpan[S] {
            ast.exSpan(s.span)
        }
        
        public exSpan[T](this ast: T, spans: IEnumerable[Span]): T where T: HasSpan[T] {
            if (spans.IsEmpty())
                ast
            else
                ast.addSpan(spans.Skip(1).FoldRight(spans.First(), (a, b) => a + b))
        }
        
        public exSpan[T](this ast: T, tokens: IEnumerable[Token]): T where T: HasSpan[T] {
            ast.exSpan(tokens.Map(t => t.span))
        }
        
        public exSpan[T, S](this ast: T, ss: IEnumerable[S]): T where T: HasSpan[T] where S: HasSpan[S] {
            ast.exSpan(ss.Map(t => t.span))
        }
        
        public consumeBlock[A](this p: Parser[Token, A]): Parser[Token, A] {
            AnnoParser(input => {
                match (input.get()) {
                    | Some(openBy) => match (p.parse(BlockInput(input, openBy))) {
                        | Parse.Result.Success(result, next) => {
                            def blockNext = next :> BlockInput;
                            match (blockNext.get()) {
                                | Some => Result.Failure("A block parser did not reach EOI.", blockNext)
                                | _ => Result.Success(result, blockNext.parent) // unwrap
                            }
                        }
                        | Parse.Result.Failure(reason, failAt) => Result.Failure(reason, failAt)
                    }
                    | _ => Result.Failure("reach EOI", input)
                }
            })
        }
        
        public inlineBlock[A](this p: Parser[Token, A]): Parser[Token, A] {
            AnnoParser(input => {
                match (input.get()) {
                    | Some(openBy) => match (p.parse(BlockInput(input, openBy))) {
                        | Parse.Result.Success(result, next) => {
                            Result.Success(result, (next :> BlockInput).parent) // unwrap EOIまで読み込まなくてもいい
                        }
                        | Parse.Result.Failure(reason, failAt) => Result.Failure(reason, failAt)
                    }
                    | _ => Result.Failure("reach EOI", input)
                }
            })
        }
    }
}