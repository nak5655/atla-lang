using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

using Atla.Lang.Parse;
using Atla.Lang.Ast;

namespace Atla.Lang.Parser
{
    public class TokenInput: Input[Token] {
        data: list[Token];
        index: int;
        
        public this(data: list[Token], index: int) {
            this.data = data;
            this.index = index;
        }
        
        public get(): option[Token] {
            if (0 <= index && index < data.Length)
                Some(data.ElementAt(index))
            else
                None()
        }
        
        public position(): Span {
            match (get()) {
                | Some(t) => t.span
                | _ when index >= data.Length && data.Length > 0 => {
                    def p = data.Last().span.hi;
                    Span(p, Position(p.lines, p.line, p.col + 1, p.index + 1)) // end of data
                }
                | _ => Span.zero()
            }
        }
        
        public next(): Input[Token] {
            TokenInput(data, index + 1)
        }
    }
    
    public class BlockInput: Input[Token] {
        public parent: Input[Token];
        openBy: Token;
        openAt: Position;
        
        public this(parent: Input[Token], openBy: Token) {
            this.parent = parent;
            this.openBy = openBy;
            this.openAt = openBy.span.lo;
        }
        
        public get(): option[Token] {
            match (parent.get()) {
                | Some(t) => {
                    if (t.span.lo.col <= openAt.col) None() else Some(t)
                }
                | _ => None()
            }
        }
        
        public position(): Span {
            parent.position() :> Span
        }
        
        public next(): Input[Token] {
            BlockInput(parent.next(), openBy)
        }
    }
    
    public class InlineInput: Input[Token] {
        public parent: Input[Token];
        openBy: Token;
        openAt: Position;
        
        public this(parent: Input[Token], openBy: Token) {
            this.parent = parent;
            this.openBy = openBy;
            this.openAt = openBy.span.lo;
        }
        
        public get(): option[Token] {
            match (parent.get()) {
                | Some(t) => {
                    if (t.span.lo.line == openAt.line && t.span.hi.line == openAt.line) Some(t) else None()
                }
                | _ => None()
            }
        }
        
        public position(): option[Span] {
            parent.position() :> option[Span]
        }
        
        public next(): Input[Token] {
            InlineInput(parent.next(), openBy)
        }
    }
    
    public variant OnceResult[I, A] {
        | Ok { value: A }
        | Ng { failure: Result[I, A] }
    }
    
    public class OffsideParserEnv: ParserEnv[Token] {
        public block[A, B](opener: Parser[Token, A], inner: Parser[Token, B]): Parser[Token, A * B] {
            AnnoParser(input => {
                def openBy = input.get();
                
                match (opener.parse(input)) {
                    | Result.Success(result, next) => {
                        match (inner.parse(BlockInput(next, openBy.Value))) {
                            | Result.Success(innerResult, innerNext) => {
                                Result.Success((result, innerResult), (innerNext :> BlockInput).parent) // unwrap
                            }
                            | Result.Failure(reason, failAt) => Result.Failure(reason, failAt)
                        }
                    }
                    | Result.Failure(reason, failAt) => Result.Failure(reason, failAt)
                }
            })
        }
        
        public blockR[A, B](opener: Parser[Token, A], inner: Parser[Token, B]): Parser[Token, B] {
            block(opener, inner).map((_, b) => b)
        }
        
        public inline[A, B](opener: Parser[Token, A], inner: Parser[Token, B]): Parser[Token, A * B] {
            AnnoParser(input => {
                def openBy = input.get();
                
                match (opener.parse(input)) {
                    | Result.Success(result, next) => {
                        match (inner.parse(InlineInput(next, openBy.Value))) {
                            | Result.Success(innerResult, innerNext) => {
                                Result.Success((result, innerResult), (innerNext :> InlineInput).parent) // unwrap
                            }
                            | Result.Failure(reason, failAt) => Result.Failure(reason, failAt)
                        }
                    }
                    | Result.Failure(reason, failAt) => Result.Failure(reason, failAt)
                }
            })
        }
    }
    
    public class Parser: OffsideParserEnv
    {
        spanned[T](ast: T, spans: list[Span]): T where T: HasSpan[T] {
            if (spans.IsEmpty)
                ast
            else
                ast.addSpan(spans.Tail.FoldRight(spans.Head, (a, b) => a + b))
        }
        spanned[T](ast: T, tokens: list[Token]): T where T: HasSpan[T] {
            spanned(ast, tokens.Map(t => t.span))
        }
        spanned[T, S](ast: T, ss: list[S]): T where T: HasSpan[T] where S: HasSpan[S] {
            spanned(ast, ss.Map(t => t.span))
        }
        
        // Exprs
        public expr: ParserRef[Token, Expr] = ParserRef();
        
        // Stmts
        public exprStmt: Parser[Token, Stmt];
        public retStmt: Parser[Token, Stmt];
        public stmt: ParserRef[Token, Stmt] = ParserRef();
        
        // Decls
        public classDecl: Parser[Token, Decl];
        public fnDecl: Parser[Token, Decl];
        public importDecl: Parser[Token, Decl];
        public decl: ParserRef[Token, Decl] = ParserRef();
        
        // Module
        public mod: Parser[Token, Ast.Module];
        
        public this() {
            def tid: Parser[Token, Token.Id] = satisfy("id", _ is Token.Id).map(_ :> Token.Id);
            def infixOp(precedence: int): Parser[Token, Token.InfixOp] {
                satisfy("infixOp", t => t is Token.InfixOp && (t :> Token.InfixOp).precedence == precedence).map(_ :> Token.InfixOp)
            }
            
            // Expr
            {
                def id = tid.map(t => spanned(Expr.Id(t.value), [t]));
                def int = satisfy("int", _ is Token.Int).map(t => spanned(Expr.Int((t :> Token.Int).value), [t]));
                def str = satisfy("string", _ is Token.String).map(t => spanned(Expr.String((t :> Token.String).value), [t]));
                def paren = delim("(")._andR(expr)._andL(delim(")"));
                def blockExpr = delim("{")._andR(stmt.many())._andL(delim("}")).map(stmts => spanned(Expr.Block(stmts), stmts)); // TODO: block name
                def factor = str._or(id)._or(int)._or(paren)._or(blockExpr);
            
                // メンバーアクセス
                def member = factor._andL(delim("."))._and(tid).map((a, b) => spanned(Expr.Member(a, b.value), [a.span, b.span]));
                def staticMember = tid._andL(delim("::"))._and(tid).map((a, b) => spanned(Expr.StaticMember(a.value, b.value), [a.span, b.span]));
                def term1 = staticMember._or(member)._or(factor);
                
                // 呼び出し式
                def term2 = term1.many1().map(es => {
                    if (es.Length == 1)
                        es.First()
                    else
                        spanned(Expr.Apply(es.First(), es.Tail), es)
                });
                
                // 二項演算
                // 優先順位と逆順なので注意(term3がpreced6, term6がpreced3になる)
                def term6 = Enumerable.Range(3, 4).Reverse().Map(i => infixOp(i)).Fold(term2, (op, acc) => acc._and(op)._and(acc).map((a_op, b) => {
                    def a = a_op[0];
                    def op = a_op[1];
                    def fn = Expr.Id(op.value).addSpan(op.span);
                    Expr.Apply(fn, [a, b]).addSpan([a.span, b.span])
                })._or(acc));
            
                expr.impl = term6;
            }
            
            exprStmt = expr.map(e => spanned(Stmt.Expr(e), [e]));
            retStmt = delim("return")._and(expr.optional()).map((a, b) => {
                def ret = spanned(Stmt.Ret(b.WithDefault(Expr.Unit())), [a]);
                if (b.IsSome) spanned(ret, [b.Value]) else ret
            });
            stmt.impl = retStmt._or(exprStmt);
            
            def typeHintFactor: Parser[Token, Ast.TypeHint] = tid.map(a => {
                spanned(TypeHint.Id(a.value), [a])
            });
            def typeHintParen: Parser[Token, Ast.TypeHint] = delim("(")._and(typeHintFactor.optional().map(mt => {
                match (mt) {
                    | Some(t) => t
                    | _ => TypeHint.Unit()
                }
            }))._and(delim(")")).map((ab, c) => spanned(ab[1], [ab[0], c]));
            def typeHintTerm = typeHintParen._or(typeHintFactor);
            def typeHint: Parser[Token, Ast.TypeHint] = typeHintTerm.many1().map(ts => {
                if (ts.Length == 1)
                    ts.First()
                else
                    TypeHint.Generics(ts.Last(), ts.FirstN(ts.Length - 1))
            });
            
            // Decls
            def fnArg: Parser[Token, FnArg] = delim("(")._andR(tid)._andL(delim(":"))._and(typeHint)._andL(delim(")")).map((a, b) => {
                spanned(FnArg(a.value, b), [a.span, b.span])
            });
            def fnArgs: Parser[Token, list[FnArg]] = fnArg.many1();
            def fnBody = stmt.many().map(stmts => spanned(Expr.Block(stmts), stmts));
            fnDecl = block(delim("fn"), skipDeclError(tid._and(fnArgs)._andL(delim(":"))._and(typeHint)._andL(delim("="))._and(fnBody).map((n_rs_r, c) => {
                def n = n_rs_r[0][0];
                def rs = n_rs_r[0][1];
                def r = n_rs_r[1];
                spanned(Decl.Fn(n.value, rs, r, c), [n.span, c.span])
            })._andL(eoi()))).map((a, b) => spanned(b, [a]));
            
            def classValField: Parser[Token, ClassItem] = delim("val")._and(tid._andL(delim(":"))._and(typeHint)._and(delim("=")._andR(expr).optional()).map((s_t, e) => {
                def (s, t) = s_t: Token.Id * Ast.TypeHint;
                ClassItem.Field(s.value, t, false, e)
            })).map((a, b) => spanned(b, [a]));
            def classVarField: Parser[Token, ClassItem] = delim("var")._and(tid._andL(delim(":"))._and(typeHint)._and(delim("=")._andR(expr).optional()).map((s_t, e) => {
                def (s, t) = s_t: Token.Id * Ast.TypeHint;
                ClassItem.Field(s.value, t, true, e)
            })).map((a, b) => spanned(b, [a]));
            def classMethod: Parser[Token, ClassItem] = fnDecl.map(d => {
                spanned(match (d) {
                    | Decl.Fn as f => ClassItem.Method(f.name, f.args, f.body)
                    | Decl.Error(reason) => ClassItem.Error(reason)
                }, [d])
            });
            def classItem = classValField._or(classVarField)._or(classMethod);
            classDecl = block(delim("class"), skipDeclError(tid._and(classItem.many()).map((a, items) => {
                spanned(Decl.Class(a.value, items), a.span :: items.Map(i => i.span).LastN(1))
            })._andL(eoi()))).map((a, b) => spanned(b, [a]));
            
            importDecl = block(delim("import"), skipDeclError(
                tid._and(delim("::")._andR(tid).many()).map((x, xs) => {
                    def path = x.value :: xs.Map(t => t.value);
                    if (xs.Length > 1)
                        spanned(Decl.Import(path), (x :: xs.LastN(1)).Map(t => t))
                    else
                        spanned(Decl.Import(path), [x])
                })._andL(eoi())
            )).map((a, b) => spanned(b, [a]));
            
            decl.impl = importDecl._or(classDecl)._or(fnDecl);
            
            mod = decl.many().map(ds => {
                spanned(Ast.Module(ds), ds)
            })._andL(eoi());
        }
        
        delim(s: string): Parser[Token, Token] {
            satisfy($"delimiter $s", t => {
                match (t) {
                    | Token.Delim(ts) when (s == ts) => true
                    | _ => false
                }
            })
        }
        
        skipDeclError(p: Parser[Token, Decl]): Parser[Token, Decl] {
            p.skipFail(ret => {
                def failure = ret :> Result[Token, Decl].Failure; // always it is failure
                def ret = Decl.Error(failure.reason);
                ret.span = failure.failAt.position() :> Span;
                ret
            })
        }
        
        skipClassItemError(p: Parser[Token, ClassItem]): Parser[Token, ClassItem] {
            p.skipFail(ret => {
                def failure = ret :> Result[Token, ClassItem].Failure; // always it is failure
                def ret = ClassItem.Error(failure.reason);
                ret.span = failure.failAt.position() :> Span;
                ret
            })
        }
    }
}