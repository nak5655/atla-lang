using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

using Atla.Lang.Cir;

// TODO Cir.from に変更(MIRがCIRの詳細に依存すべきではない)
namespace Atla.Lang.Mir
{
    public class Trans
    {
        labelTable: Hashtable[Mir.Label, Cir.Label] = Hashtable(); // TODO これフレーム毎でよさそう
        
        public load(frame: Frame, mir: Mir.Value): Result[IEnumerable[Cir.Ins]] {
            match (mir) {
                | Mir.Value.Imm(imm) => match (imm) {
                    | Mir.Imm.Bool(v) => Result.Success([Cir.Ins.LdInt32(v.toInt())])
                    | Mir.Imm.Int(v) => Result.Success([Cir.Ins.LdInt32(v)])
                    | Mir.Imm.String(s) => Result.Success([Cir.Ins.LdStr(s)])
                }
                | Mir.Value.Sym(sym) => match (frame.resolve(sym)) {
                    | Some(FramePosition.Loc(i)) => Result.Success([Cir.Ins.LdLoc(i)])
                    | Some(FramePosition.Arg(i)) => Result.Success([Cir.Ins.LdArg(i)])
                    | _ => Result.Failure($"Symbol $sym is invalid.") 
                }
            }
        }
        
        public store(frame: Frame, sym: Symbol): Result[IEnumerable[Cir.Ins]] {
            match (frame.resolve(sym)) {
                    | Some(FramePosition.Loc(i)) => Result.Success([Cir.Ins.StLoc(i)])
                    | Some(FramePosition.Arg(i)) => Result.Success([Cir.Ins.StArg(i)])
                    | _ => Result.Failure($"Symbol $sym is invalid.") 
            }
        }
        
        public trans(op: Mir.OpCode): Cir.Ins {
            match (op) {
                | Mir.OpCode.Add => Cir.Ins.Add()
                | Mir.OpCode.Sub => Cir.Ins.Sub()
                | Mir.OpCode.Mul => Cir.Ins.Mul()
                | Mir.OpCode.Div => Cir.Ins.Div()
                | Mir.OpCode.Or => Cir.Ins.Or()
                | Mir.OpCode.And => Cir.Ins.And()
                | Mir.OpCode.Eq => Cir.Ins.Eq()
            }
        }
        
        public trans(frame: Frame, mir: Mir.Ins): Result[IEnumerable[Cir.Ins]] {
            match (mir) {
                | Mir.Ins.TAC(dst, lhs, op, rhs) => load(frame, lhs).bind(a => load(frame, rhs).bind(b => match (frame.resolve(dst)) {
                    | Some(FramePosition.Loc(i)) => Result.Success(a.Concat(b).Concat([trans(op), Cir.Ins.StLoc(i)]))
                    | Some(FramePosition.Arg(i)) => Result.Success(a.Concat(b).Concat([trans(op), Cir.Ins.StArg(i)]))
                    | _ => Result.Failure($"Symbol $dst is invalid.")
                }))
                | Mir.Ins.Assign(sym, rhs) => load(frame, rhs).bind(vs => store(frame, sym).map(st => vs.Concat(st)))
                | Mir.Ins.CallStatic(mi, args) => {
                    args.Map(a => load(frame, a)).seq().map(vs => vs.flatten().Concat([Cir.Ins.Call(mi)]))
                }
                | Mir.Ins.CallAssign(dst, mi, args) => {
                    args.Map(a => load(frame, a)).seq().bind(vs => store(frame, dst).map(st => vs.flatten().Concat([Cir.Ins.Call(mi)].Concat(st))))
                }
                | Mir.Ins.MarkLabel(label) => {
                    when (!labelTable.ContainsKey(label))
                        labelTable.Add(label, Cir.Label());
                    def cirLabel = labelTable.Get(label).Value;
                    Result.Success([Cir.Ins.MarkLabel(cirLabel)]) // MarkLabelがダブらないのはMIRで保証される
                }
                | Mir.Ins.Jump(label) => {
                    when (!labelTable.ContainsKey(label))
                        labelTable.Add(label, Cir.Label());
                    def cirLabel = labelTable.Get(label).Value;
                    Result.Success([Cir.Ins.BrS(cirLabel)])
                }
                | Mir.Ins.JumpTrue(pred, label) => {
                    when (!labelTable.ContainsKey(label))
                        labelTable.Add(label, Cir.Label());
                    def cirLabel = labelTable.Get(label).Value;
                    load(frame, pred).map(ld => ld.Concat([Cir.Ins.BrTrueS(cirLabel)]))
                }
                | Mir.Ins.RetValue(v) => load(frame, v).map(ld => ld.Concat([Cir.Ins.Ret()]))
                | Mir.Ins.Ret => Result.Success([Cir.Ins.Ret()])
            }
        }
        
        public trans(mir: Mir.Method): Result[Cir.Method] {
            def body = mir.body.Map(i => trans(mir.frame, i)).seq().map(r => r.flatten());
            body.map(b => {
                if (b.Count() > 0 && !(b.Last() is Cir.Ins.Ret)) {
                    Cir.Method(mir.builder, mir.frame, b.ToList().ToNList() + [Cir.Ins.Ret()]) // voidを返す関数でも最後にretが必要
                } else {
                    Cir.Method(mir.builder, mir.frame, b.ToList().ToNList())
                }
            })
        }
        
        public trans(mir: Mir.Type): Result[Cir.Type] {
            mir.methods.Map(m => trans(m)).seq().map(ms => Cir.Type(mir.builder, ms.ToList().ToNList()))
        }
        
        public trans(mir: Mir.Module): Result[Cir.Module] {
            mir.types.Map(t => trans(t)).seq().bind(ts => {
                mir.methods.Map(m => trans(m)).seq().map(ms => {
                    Cir.Module(mir.builder, ts.ToList().ToNList(), ms.ToList().ToNList())
                })
            })
        }
        
        public trans(mir: Mir.Assembly): Result[Cir.Assembly] {
            mir.modules.Values.Map(m => trans(m)).seq().map(ms => Cir.Assembly(mir.fileName, mir.builder, ms.ToList().ToNList()))
        }
    }
    
    public module MirTransExtensions {
        public toInt(this v: bool): int {
            if (v) 1 else 0
        }
    }
}
