using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;

using System.Reflection;
using System.Reflection.Emit;

// ネストした関数やスコープを除去済み
// 関数のローカル変数のスタック位置が確定 -> 変数名を削除して添え字でアクセスできる
// 関数や型はMethodInfoとSystem.Typeで参照する
// K正規化済み
// TODO 同じMarkLabelが複数ないかチェック
namespace Atla.Lang.Mir
{
    public variant Imm {
        | Bool { value: bool }
        | Int { value: int }
        | String { value: string }
        
        public override ToString(): string {
            match (this) {
                | Bool(v) => $"Bool($v)"
                | Int(v) => $"Int($v)"
                | String(v) => $"String($v)"
            }
        }
    }
    
    public variant Value {
        | Imm { value: Mir.Imm }
        | Sym { value: Symbol }
        
        public override ToString(): string {
            match (this) {
                | Imm(v) => $"Imm($v)"
                | Sym(v) => $"Sym($v)"
            }
        }
    }
    
    public enum OpCode {
        | Add // 算術演算
        | Sub
        | Mul
        | Div
        | Or // 論理演算
        | And
        | Eq // 同値
    }
    
    public class Label {
            public override ToString(): string {
                $"Label($(GetHashCode()))"
            }
    }
    
    // ここではまだスタックマシンじゃないので注意 (K正規化まではしてる)
    public variant Ins {
        | Assign {
            name: Symbol;
            value: Value;
            
            public override ToString(): string {
                $"$name = $value"
            }
        }
        | TAC {
            dest: Symbol; lhs: Value; op: OpCode; rhs: Value;
        
            public override ToString(): string {
                $"$dest = $lhs $op $rhs"
            }
        } // three addess code
        | Call {
            method: MethodInfo;
            args: list[Value];
            
            public override ToString(): string {
                $"$method($(args.joinToString(\", \")))"
            }
        }
        | CallAssign {
            dst: Symbol;
            method: MethodInfo;
            args: list[Value];
            
            public override ToString(): string {
                $"$dst = $method($(args.joinToString(\", \")))"
            }
        }
        | Ret
        | RetValue {
            value: Value;
            
            public override ToString(): string {
                $"return $value"
            }
        }
        | Jump {
            label: Label;
            
            public override ToString(): string {
                $"Jump $label"
            }
        }
        | JumpTrue {
            value: Value;
            label: Label;
            
            public override ToString(): string {
                $"JumpTrue $value $label"
            }
        }
        | MarkLabel {
            label: Label;
            
            public override ToString(): string {
                $"MarkLabel $label"
            }
        }
    }
    
    public class Method {
        public name: string;
        public builder: MethodBuilder; // subclass of MethodInfo
        public mutable body: list[Ins];
        
        public frame: Frame = Frame();
        
        public this(ty: Type, name: string, args: list[System.Type], ret: System.Type) {
            this.name = name;
            builder = ty.builder.DefineMethod(name, MethodAttributes.Public, ret, args.ToArray());
        }
        
        public this(mod: Module, name: string, args: list[System.Type], ret: System.Type) {
            this.name = name;
            builder = mod.builder.DefineGlobalMethod(name, MethodAttributes.Public | MethodAttributes.Static, ret, args.ToArray());
        }
    }
    
    public interface MethodContainer {
        defineMethod(name: string, args: list[System.Type], ret: System.Type): Method;
    }
    
    public class Type: MethodContainer {
        public builder: TypeBuilder;
        
        public methods: List[Method];
        
        public this(mod: Module, name: string) {
            this.builder = mod.builder.DefineType(name, TypeAttributes.Public, typeof(System.Object));
            this.methods = List();
        }
        
        public defineMethod(name: string, args: list[System.Type], ret: System.Type): Method {
            def method = Method(this, name, args, ret);
            methods.Add(method);
            method
        }
    }
    
    public class Module: MethodContainer {
        public builder: ModuleBuilder;
        
        public types: List[Type];
        public methods: List[Method];
        
        public this(asm: Assembly, name: string) {
            this.builder = asm.builder.DefineDynamicModule(name, asm.fileName);
            this.types = List();
            this.methods = List();
        }
        
        public defineMethod(name: string, args: list[System.Type], ret: System.Type): Method {
            def method = Method(this, name, args, ret);
            methods.Add(method);
            method
        }
    }
    
    public class Assembly {
        public name: AssemblyName;
        public fileName: string;
        public builder: AssemblyBuilder;
        
        public modules: Hashtable[string, Module];
        
        public this(name: string, filePath: string) {
            this.name = AssemblyName(name);
            this.fileName = System.IO.Path.GetFileName(filePath);
            this.builder = Thread.GetDomain().DefineDynamicAssembly(this.name, AssemblyBuilderAccess.Save, System.IO.Path.GetDirectoryName(filePath));
            this.modules = Hashtable();
        }
    }
}
