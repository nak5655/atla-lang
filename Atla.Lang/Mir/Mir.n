using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

using System.Reflection;
using System.Reflection.Emit;

// ネストした関数やスコープを除去済み
// 関数のローカル変数のスタック位置が確定 -> 変数名を削除して添え字でアクセスできる
// 関数や型はMethodInfoとSystem.Typeで参照する
// K正規化済み
namespace Atla.Lang.Mir
{
    public variant Imm {
        | Int { value: int }
        | String { value: string }
    }
    
    [Record]
    public class Symbol {
        public name: string;
        public type: System.Type;
    }
    
    public variant Value {
        | Imm { value: Mir.Imm }
        | Sym { value: Symbol }
    }
    
    public variant Ins {
        | Assign {
            name: Symbol;
            value: Value;
        }
        | Call {
            method: MethodInfo;
            args: list[Value];
        }
        | CallAssign {
            name: Symbol;
            method: MethodInfo;
            args: list[Value];
        }
        | Ret
        | RetValue {
            value: Value;
        }
        | Jump {
            label: Label;
        }
        | Label
    }
    
    public class Method {
        public name: string;
        public builder: MethodBuilder; // subclass of MethodInfo
        public mutable body: list[Ins];
        
        public frame: Frame = Frame();
        
        public this(ty: Type, name: string, args: list[System.Type], ret: System.Type) {
            this.name = name;
            builder = ty.builder.DefineMethod(name, MethodAttributes.Public, ret, args.ToArray());
        }
        
        public this(mod: Module, name: string, args: list[System.Type], ret: System.Type) {
            this.name = name;
            builder = mod.builder.DefineGlobalMethod(name, MethodAttributes.Public | MethodAttributes.Static, ret, args.ToArray());
        }
    }
    
    public interface MethodContainer {
        defineMethod(name: string, args: list[System.Type], ret: System.Type): Method
    }
    
    public class Type: MethodContainer {
        public builder: TypeBuilder;
        
        public methods: List[Method];
        
        public this(mod: Module, name: string) {
            this.builder = mod.builder.DefineType(name, TypeAttributes.Public, typeof(System.Object));
            this.methods = List();
        }
        
        public defineMethod(name: string, args: list[System.Type], ret: System.Type): Method {
            def method = Method(this, name, args, ret);
            methods.Add(method);
            method
        }
    }
    
    public class Module: MethodContainer {
        public builder: ModuleBuilder;
        
        public types: List[Type];
        public methods: List[Method];
        
        public this(asm: Assembly, name: string, fileName: string) {
            this.builder = asm.builder.DefineDynamicModule(name, fileName);
            this.types = List();
            this.methods = List();
        }
        
        public defineMethod(name: string, args: list[System.Type], ret: System.Type): Method {
            def method = Method(this, name, args, ret);
            methods.Add(method);
            method
        }
    }
    
    public class Assembly {
        public name: AssemblyName;
        public builder: AssemblyBuilder;
        
        public modules: Hashtable[string, Module];
        
        public this(name: string) {
            this.name = AssemblyName(name);
            this.builder = AssemblyBuilder.DefineDynamicAssembly(this.name, AssemblyBuilderAccess.Save);
            this.modules = Hashtable();
        }
        
        public DefineModule(name: string, fileName: string): Module {
            def mod = Module(this, name, fileName);
            modules.Add(name, mod);
            mod
        }
    }
}
