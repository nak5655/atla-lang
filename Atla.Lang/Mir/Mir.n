using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

/**
CPU命令に近い形式 実行速度最適化の対象
LLVM IR と同等
型確定済み
変数名なし　レジスタ割り当て済み
K正規化済み
**/
namespace Atla.Lang.Mir
{
    public variant Type: System.IEquatable[Type] {
        | String
        | Fn { args: list[Type]; ret: Type }
        | Void
        
        public override GetHashCode() : int {
            match (this) {
                | String => 0
                | Void => 1
                | Fn(args, ret) => args.Sum(arg => arg.GetHashCode()) + ret.GetHashCode()
            }
        }
        
        public override Equals(other: object): bool implements System.IEquatable[Type].Equals {
            match (this) {
                | String => other is Type.String
                | Void => other is Type.Void
                | Fn(args, ret) => other is Type.Fn && (args.Zip((other :> Type.Fn).args).All((a,b) => a.Equals(b))) && ret.Equals((other :> Type.Fn).ret)
            }
        }
    }
    
    [Record]
    public class Id: System.IComparable[Id], System.IEquatable[Id]
    {
        public name: string;
        public type: Type;
        
        public override GetHashCode() : int {
            name.GetHashCode()
        }
        
        public override Equals(other: object): bool implements System.IEquatable[Id].Equals {
            if (other is Id)
                this.name == (other :> Id).name && Equals(this.type, (other :> Id).type)
            else
                false
        }
        
        public CompareTo(other : Id) : int {
          def res = string.CompareOrdinal(name, other.name);
          if (res == 0)
          {
              type.GetHashCode() - other.type.GetHashCode()
          }
          else
              res
        }
    }
    
    public variant Imm
    {
        | String { value: string }
    }
    
    public variant Arg {
        | Id { value: Atla.Lang.Mir.Id }
        | Imm { value: Atla.Lang.Mir.Imm }
    }
    
    public variant Ins {
        | Call { func: Id; args: list[Arg] }
        | CallNative { method: MethodInfo; args: list[Arg] }
        | Ret
    }
    
    public variant Decl {
        | Fn { id: Id; body: list[Ins] }
    }
    
    [Record]
    public class Module
    {
        public name: string;
        public mutable decls: list[Decl];
    }
}
