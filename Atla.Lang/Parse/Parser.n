using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;

using System;
using System.Collections.Generic;
using System.Linq;

using Atla.Lang.Parse;

namespace Atla.Lang.Parse
{
    // instead of annonymous class
    public class AnnoParser[I, A]: Parser[I, A] {
        mutable _apply: Input[I] -> Result[I, A];
        
        public this(apply: Input[I] -> Result[I, A]) {
            _apply = apply
        }
        
        public override apply(input: Input[I]): Result[I, A] {
            _apply(input)
        }
    }
    
    public abstract class Parser[I, A]
    {
        mutable cache: Hashtable[System.Object, Result[I, A]];
        
        public this() {
            cache = Hashtable();
        }
        
        public abstract apply(input: Input[I]): Result[I, A];
        
        public parse(input: Input[I]): Result[I, A] {
            cache.GetValueOrDefault(input.position(), apply(input))
        }

        public map[B](f: A -> B): Parser[I, B] {
            AnnoParser((input) => {
                match (parse(input)) {
                    | Result.Success(result, next) => Result.Success(f(result), next)
                    | Result.Failure(reason, failAt) => Result.Failure(reason, failAt)
                }
            })
        }
        
        public _and[B](other: Parser[I, B]): Parser[I, A * B] {
            AnnoParser(input => {
                match (parse(input)) {
                    | Result.Success as lhs => {
                        match (other.parse(lhs.next)) {
                            | Result.Success as rhs => Result.Success((lhs.result, rhs.result), rhs.next)
                            | Result.Failure(reason, failAt) => Result.Failure(reason, failAt)
                        }
                    }
                    | Result.Failure(reason, failAt) => Result.Failure(reason, failAt)
                }
            })
        }
        
        public _andL[B](other: Parser[I, B]): Parser[I, A] {
            (this._and(other)).map(res => res[0])
        }
        
        public _andR[B](other: Parser[I, B]): Parser[I, B] {
            (this._and(other)).map(res => res[1])
        }
        
        public _or(other: Parser[I, A]): Parser[I, A] {
            AnnoParser(input => {
                match (parse(input)) {
                    | Result.Success as lhs => lhs
                    | Result.Failure => other.parse(input)
                }
            })
        }
        
        public many(): Parser[I, list[A]] {
            AnnoParser(input => {
                mutable current = input;
                def ret: List[A] = List();
                while (true) {
                    match (parse(current)) {
                        | Result.Success(result, next) => {
                            ret.Add(result);
                            current = next;
                        }
                        | Result.Failure => break
                    }
                }
                Result.Success(ret.ToNList(), current)
            })
        }
        
        public many1(): Parser[I, list[A]] {
            _and(many()).map((x, xs) => x :: xs)
        }
        
        public sepBy[B](sep: Parser[I, B]): Parser[I, list[A]] {
            AnnoParser(input => {
                mutable current = input;
                def ret: List[A] = List();
                while (true) {
                    match (_andL(sep).parse(current)) {
                        | Result.Success(result, next) => {
                            ret.Add(result);
                            current = next;
                            continue;
                        }
                        | _ => ()
                    }
                    match (parse(current)) {
                        | Result.Success(result, next) => {
                            ret.Add(result);
                            current = next;
                        }
                        | Result.Failure => break
                    }
                    break
                }
                Result.Success(ret.ToNList(), current)
            })
        }
        
        public optional(): Parser[I, option[A]] {
            AnnoParser(input => {
                match (parse(input)) {
                    | Result.Success(result, next) => Result.Success(Some(result), next)
                    | Result.Failure(_, failAt) => Result.Success(None(), failAt)
                }
            })
        }
        
        public notFollowedBy[B](other: Parser[I, B]): Parser[I, A] {
            AnnoParser(input => {
                match (parse(input)) {
                    | Result.Success as res => match (other.parse(res.next)) {
                        | Result.Success as r => Result.Failure($"unexpected $(r.result)", res.next)
                        | _ => res
                    }
                    | _ as res => res
                }
            })
        }
        
        public skipFail(f: Result[I, A] -> A): Parser[I, A] {
            AnnoParser(input => {
                match (parse(input)) {
                    | Result.Success as res => res
                    | Result.Failure as res => {
                        mutable current = input;
                        while (current.get().IsSome) {
                            current = current.next();
                        }
                        
                        Result.Success(f(res), current)
                    }
                }
            })
        }
        
        public log(name: string): Parser[I, A] {
            AnnoParser(input => {
                Console.WriteLine($"ParserLog: $name");
                parse(input)
            })
        }
    }
}
