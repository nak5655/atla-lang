using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;

using System;
using System.Collections.Generic;
using System.Linq;

using Atla.Lang.Parse;

namespace Atla.Lang
{
    public class Compiler
    {
        public mutable handleProblem: Problem -> void;
        
        public this(handleProblem: Problem -> void) {
            this.handleProblem = handleProblem;
        }
        
        public updateModule(asm: Hir.Assembly, name: string, code: string): option[Hir.Module] {
            def lexer = Atla.Lang.Parser.Lexer();
            match (lexer.tokenize(code)) {
                | Atla.Lang.Parse.Result.Success(tokens, _) => {        
                    def parser = Atla.Lang.Parser.Parser();
                    match (parser.mod.parse(Atla.Lang.Parser.TokenInput(tokens, 0))) {
                        | Atla.Lang.Parse.Result.Success(ast, _) => { 
                            def hir = Atla.Lang.Ast.Trans().trans(asm.scope, ast, name);
                            
                            def transProblems = hir.scanErrors();
                            when (transProblems.Count() > 0) {
                                foreach ((error, span) in transProblems) {
                                    handleProblem(Problem(Severity.Error, error.ToString(), span))
                                }
                                return None();
                            }
                            
                            Atla.Lang.Hir.Typing().typing(hir);
                            def typingProblems = hir.scanErrors();
                            when (typingProblems.Count() > 0) {
                                foreach ((error, span) in typingProblems) {
                                    handleProblem(Problem(Severity.Error, error.ToString(), span))
                                }
                                return None();
                            }
            
                            asm.modules[name] = hir;
            
                            Some(hir)
                        }
                        | Atla.Lang.Parse.Result.Failure(reason, failAt) => {
                            handleProblem(Problem(Severity.Error, reason, failAt.position() :> Span));
                            None()
                        }
                    }
                }
                | Atla.Lang.Parse.Result.Failure(reason, failAt) => {
                    def pos = failAt.position() :> Atla.Lang.Parse.Position;
                    handleProblem(Problem(Severity.Error, reason, Span(pos, pos.right())));
                    None()
                }
            }
        }
        
        public compileHirToMir(asm: Hir.Assembly): option[Mir.Assembly] {
            Atla.Lang.Hir.Flat().flat(asm);
            def flatErrors = asm.scanErrors();
            when (flatErrors.Count() > 0) {
                foreach ((error, span) in flatErrors) {
                    handleProblem(Problem(Severity.Error, error.ToString(), span))
                }
                return None();
            }
            
            match (Atla.Lang.Hir.Trans().trans(asm)) {
                | Atla.Lang.Result.Success(mir) => {
                    Some(mir)
                }
                | Atla.Lang.Result.Failure(msg) => {
                    handleProblem(Problem(Severity.Error, msg, Span.zero())); // TODO Span
                    None()
                }
            }
        }
        
        public compileMirToCir(asm: Mir.Assembly): option[Cir.Assembly] {
            match (Atla.Lang.Mir.Trans().trans(asm)) {
                | Atla.Lang.Result.Success(cir) => {
                    Some(cir)
                }
                | Atla.Lang.Result.Failure(msg) => {
                    handleProblem(Problem(Severity.Error, msg, Span.zero())); // TODO Span
                    None()
                }
            }
        }
        
        public compile(asm: Hir.Assembly): void {
            match (compileHirToMir(asm)) {
                | Some(mir) => {
                    match (compileMirToCir(mir)) {
                        | Some(cir) => {
                            Cir.Emit().emit(cir);
                        }
                        | _ => {
                            handleProblem(Problem(Severity.Error, "Compile Error: Could not compile the MIR to CIR.", Span.zero()));
                        }
                    }
                }
                | _ => {
                    handleProblem(Problem(Severity.Error, "Compile Error: Could not compile the HIR to MIR.", Span.zero()));
                }
            }
        }
    }
}
