using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Reflection;

using Atla.Lang.Parse;
using Atla.Lang;

// TODO やっぱりこのクラスはHir.Typeに移動したほうがいい（MIRに不要な型が多すぎる & HIRに依存してる）
namespace Atla.Lang
{
    public variant TypeError {
        | Undefined {
            name: string;
            
            public override ToString(): string {
                $"Type $name is not defined."
            }
        }
        | RecursiveReference { a: Type; b: Type }
        | Ambiguous { types: list[Type] }
        | UnificationFailure {
            refered: Type; referer: Type;
            
            public override ToString(): string {
                $"Could not unify type $refered and $referer."
            }
        }
        | InferenceUnmatched { types: list[Type] }
        | InferenceFailure { message: string }
    }
    
    public interface TypeScope {
        resolveType(name: string): Type
    }
    
    public variant TypeHint: HasSpan[TypeHint] {
        | None
        | Name {
            // TODO class path
            name: string;
            
            public override ToString(): string {
                name
            }
        }
        | Fn {
            args: list[TypeHint]; ret: TypeHint;
            
            public override ToString(): string {
                def sb = StringBuilder();
                if (args.Length > 0) {
                    _ = sb.Append(args.Head.ToString());
                    foreach (arg in (args.Tail + [ret])) {
                        _ = sb.Append(" -> ").Append(arg.ToString());
                    }
                } else {
                    _ = sb.Append(ret.ToString());
                }
                sb.ToString()
            }
        }
        | Generics { _base: TypeHint; _params: list[TypeHint] }
        
        public resolve(scope: TypeScope): Type { match (this) {
            | TypeHint.None => Type.Unknown()
            | TypeHint.Name(name) => scope.resolveType(name)
            | TypeHint.Fn(args, ret) => Type.Fn(args.Map(arg => arg.resolve(scope)), ret.resolve(scope))
            | TypeHint.Generics(_base, _params) => Type.Generics(_base.resolve(scope), _params.Map(p => p.resolve(scope)))
        }}
        
        public static Unit(): TypeHint {
            Name(Type.UNIT_NAME)
        }
    }
    
    public class TypeField {
        public name: string;
        public type: Type.Var;
        public typeHint: TypeHint;
        
        public this(name: string, typeHint: TypeHint) {
            this.name = name;
            this.typeHint = typeHint;
            this.type = Type.Var();
        }
        
        public scanErrors(defaultSpan: Span): IEnumerable[Hir.Error * Span] {
            type.scanErrors(defaultSpan)
        }
    }
    
    public variant Type: System.IEquatable[Type] {
        | Unknown {
            public override ToString(): string {
                "Unknown"
            }
        }
        | OneOf { mutable types: list[Type] }
        | Var {
            public mutable instance: Type;
            
            public this() {
                instance = Unknown();
            }
            
            // VarがVarを参照する場合、途中の参照は無意味なので経路圧縮する
            // (間の型変数のinstanceは変わらないことが保証できる)
            public simplify(): Var {
                match (instance) {
                    | Var(v is Var) => {
                        instance = v
                    }
                    | _ => {}
                }
                this
            }
            
            public override ToString(): string {
                $"Var($instance)"
            }
        }
        | Define {
            public name: string;
            public fields: List[TypeField];
            public methods: List[Hir.Method];
        
            public scope: Hir.Scope.Type;
        
            public this(parentScope: Hir.Scope, name: string) {
                this.name = name;
                fields = List();
                methods = List();
            
                this.scope = Hir.Scope.Type(parentScope, name);
            }
            
            public scanMyErrors(defaultSpan: Span): IEnumerable[Hir.Error * Span] {
                fields.SelectMany(_.scanErrors(defaultSpan))
                    .Concat(methods.SelectMany(_.scanErrors()))
            }
            
            public override ToString(): string {
                $"Define($name)"
            }
        }
        | Native {
            public type: System.Type;
            
            public override Equals(other: object): bool {
                match (other) {
                    | Native(t) => t.Equals(type)
                    | _ => false
                }
            }
            
            public override ToString(): string {
                $"Native($type)"
            }
        }
        | Fn {
            args: list[Type]; ret: Type;
            
            public override ToString(): string {
                def argsStr = args.joinToString(", ");
                $"Fn($argsStr): $ret"
            }
        }
        | Generics { _base: Type; _params: list[Type] }
        | Error {
            public this(error: TypeError) {
                this.errors.Add(error);
            }
            
            public this(errors: IEnumerable[TypeError]) {
                this.errors.AddRange(errors);
            }
        }
        
        // Primery Types
        public static UNIT_NAME: string = "Unit";
        public static BOOL_NAME: string = "Bool";
        public static INT_NAME: string = "Int";
        public static FLOAT_NAME: string = "Float";
        public static DOUBLE_NAME: string = "Double";
        public static STRING_NAME: string = "String";
        
        mutable _systemType: System.Type; // キャッシュ
        public errors: List[TypeError] = List();
        
        public canUnify(other: Type): bool {
            def op = other.pruned(); // ここでotherを解決する(最初だけ)
            _canUnify(op) // 再帰で処理
        }
        // 再帰用(otherをprunedしない)
        _canUnify(other: Type): bool {
            match ((this, other)) {
                | (Unknown, _) => true
                | (_, Unknown) => true
                | (e is Error, _) => false
                | (_, e is Error) => false
                | (Var(t), _) => t._canUnify(other)
                | (OneOf(ts), _) => ts.Any(_._canUnify(other))
                | (_, OneOf(ts)) => ts.Any(_.canUnify(this)) // thisはprunedしてないので再帰の仕方が少し違うので注意
                | (Fn(a, b), Fn(c, d)) when a.Length == c.Length => a.Zip(c).All((x,y) => x.canUnify(y)) && b.canUnify(d) // 各パラメーターはprunedされてないので注意
                | (Generics(a, bs), Generics(c, ds)) when bs.Length == ds.Length => a.canUnify(c) && bs.Zip(ds).All((b,d) => b.canUnify(d)) // 各パラメーターはprunedされてないので注意
                | (Native(a), Native(b)) when a.Equals(b) => true // TODO ネイティブの継承を考慮する
                | (Define as a, Define as b) => a.Equals(b)
                // TODO
                | _ => false
            }
        }
        
        public unify(other: Type): Type {
            // check already unified
            when (this.unVar() == other.unVar()) {
                return this;
            }
            
            match ((this, other)) {
                | (Unknown, _) => other
                | (_, Unknown) => this
                | (e is Error, _) => Type.Error(e.errors.ToNList() + [TypeError.UnificationFailure(this, other)])
                | (_, e is Error) => Type.Error(e.errors.ToNList() + [TypeError.UnificationFailure(other, this)])
                | (it is Var, _) => {
                    if (!it.occursIn(other)) {
                        it.instance = it.instance.unify(other);
                    } else {
                        it.instance = Type.Error(TypeError.RecursiveReference(this, other));
                    }
                    it.simplify()
                }
                | (_, it is Var) => {
                    if (!it.occursIn(this)) {
                        it.instance = it.instance.unify(this); // thisが型変数じゃないのでotherをunifyして返す
                    } else {
                        it.instance = Type.Error(TypeError.RecursiveReference(other, this));
                    }
                    it.simplify()
                }
                | (OneOf(ts) as it, _) => {
                    it.types = ts.Filter(_.canUnify(other));
                    it
                }
                | (_, OneOf(ts) as it) => {
                    it.types = ts.Filter(_.canUnify(other));
                    it
                }
                | (Fn(a, b), Fn(c, d)) when a.Length == c.Length => Fn(a.Zip(c).Map((x, y) => x.unify(y)), b.unify(d))
                | (Generics(a, bs), Generics(c, ds)) when bs.Length == ds.Length => Generics(a.unify(c), bs.Zip(ds).Map((b,d) => b.unify(d)))
                | (Native(a), Native(b)) when a.Equals(b) => this // TODO ネイティブの継承を考慮する
                | (Define as a, Define as b) when a.Equals(b) => this
                // TODO
                | _ => {
                    Type.Error(TypeError.UnificationFailure(this, other))
                }
            }
        }
        
        // thisは変更しないで型変数を可能な限り取り除く
        public pruned(): Type {
            match (this) {
                | Var(t) => t.pruned()
                | OneOf(ts) => if (ts.Length == 1) ts.First().pruned() else if (ts.Length == 0) Type.Error(TypeError.InferenceFailure("No one match for this type.")) else Type.Error(TypeError.Ambiguous(ts))
                | Fn(args, ret) => Fn(args.Map(_.pruned()), ret.pruned())
                | Generics(b, ps) => Generics(b.pruned(), ps.Map(_.pruned()))
                | _ => this
            }
        }
        
        // pruneと違って型関数内の型変数を置換しない
        public unVar(): Type {
            match (this) {
                | Var(t) => {
                    match (t) {
                        | it is Var => it.unVar()
                        | _ => t
                    }
                }
                | _ => this
            }
        }
            
        public occursIn(other: Type): bool {
            when (this == other) {
                return true
            }
            
            match (other) {
                | Var(t) => occursIn(t)
                | OneOf => false // 型を構成しているわけではないのでチェックしない(してはいけない 常にUnifyできる)
                | Fn(args, ret) => args.Any(arg => occursIn(arg)) || occursIn(ret)
                | Generics(b, ps) => occursIn(b) || ps.Any(p => occursIn(p))
                | _ => false
            }
        }
        
        public scanErrors(defaultSpan: Span): IEnumerable[Hir.Error * Span] {
            def ret = match (this) {
                | Var(t) => t.scanErrors(defaultSpan)
                | Fn(args, ret) => args.SelectMany(_.scanErrors(defaultSpan)).Concat(ret.scanErrors(defaultSpan))
                | Generics(b, ps) => ps.SelectMany(_.scanErrors(defaultSpan)).Concat(b.scanErrors(defaultSpan))
                | Define => [] // ここで型定義の内容をスキャンすると無限ループするのでここでエラーチェックはしない（個別にチェックする）
                | _ => []
            };
            ret.Concat(errors.Map(e => (Hir.Error.Type(e), defaultSpan)))
        }
        
        public ToSystemType(): System.Type {
            when (_systemType == null) {
                _systemType = match (this.pruned()) {
                    // TODO
                    | Native(t) => t
                    | Generics(b, ps) => {
                        def _base = b.ToSystemType();
                        if (_base.IsGenericTypeDefinition)
                            _base.MakeGenericType(ps.Map(_.ToSystemType()).ToArray())
                        else if (_base == typeof(System.Array)) { // TODO typeofは遅い? キャッシュしたほうがいいかも?
                            if (ps.Length == 1)
                                ps.First().ToSystemType().MakeArrayType()
                            else
                                throw Exception("Could not make array type of plural types.") // TODO Result[System.Type]
                        } else {
                            throw Exception("Notimplemented") // TODO
                        }
                    }
                    | Fn(args, ret) => {
                        if (ret.isVoid()) {
                            def ps = args.Map(_.ToSystemType()).ToArray();
                            match (args.Length) {
                                | 0
                                | 1 when args.First().isVoid() => typeof(System.Action)
                                | 1 => typeof(System.Action[_]).MakeGenericType(ps)
                                | 2 => typeof(System.Action[_, _]).MakeGenericType(ps)
                                | 3 => typeof(System.Action[_, _, _]).MakeGenericType(ps)
                                | 4 => typeof(System.Action[_, _, _, _]).MakeGenericType(ps)
                                | 5 => typeof(System.Action[_, _, _, _, _]).MakeGenericType(ps)
                                // TODO
                            }
                        } else {
                            def ps = args.Map(_.ToSystemType()).Concat([ret.ToSystemType()]).ToArray();
                            match (args.Length) {
                                | 0
                                | 1 when args.First().isVoid() => typeof(System.Func[_]).MakeGenericType([ret.ToSystemType()].ToArray())
                                | 1 => typeof(System.Func[_, _]).MakeGenericType(ps)
                                | 2 => typeof(System.Func[_, _, _]).MakeGenericType(ps)
                                | 3 => typeof(System.Func[_, _, _, _]).MakeGenericType(ps)
                                | 4 => typeof(System.Func[_, _, _, _, _]).MakeGenericType(ps)
                                | 5 => typeof(System.Func[_, _, _, _, _, _]).MakeGenericType(ps)
                                // TODO
                            }
                        }
                    }
                }
            }
            _systemType
        }
        
        public override GetHashCode() : int {
            match (this) {
                | Unknown => (this: object).GetHashCode()
                | Var(t) => t.GetHashCode()
                | Define => (this: object).GetHashCode()
                | Native(t) => t.GetHashCode()
                | Fn(args, ret) => args.Sum(_.GetHashCode()) + ret.GetHashCode()
                | Generics(b, ps) => ps.Sum(_.GetHashCode()) + b.GetHashCode()
                | Error => (this: object).GetHashCode()
            }
        }
        
        public override Equals(other: object): bool implements System.IEquatable[Type].Equals {
            match (this, other) {
                | (Var(t), _) => t.Equals(other)
                | (_, Var(s)) => this.Equals(s)
                | (Unknown, _) => Object.Equals(this, other)
                | (Define, _) => Object.Equals(this, other)
                | (Native(t), Native(s)) => t.Equals(s)
                | (Fn(xs, y), Fn(ts, s)) when xs.Length == ts.Length => xs.Zip(ts).All((x, t) => x.Equals(t)) && y.Equals(s)
                | (Generics(x, ys), Generics(t, ss)) when ys.Length == ss.Length => ys.Zip(ss).All((x, t) => x.Equals(t)) && x.Equals(t)
                | (Error, _) => Object.Equals(this, other)
                | _ => false
            }
        }
        
        public isVoid(): bool {
            this.ToSystemType() == typeof(void)
        }
    }
}
