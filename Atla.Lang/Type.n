using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using Atla.Lang.Parse;
using Atla.Lang;

namespace Atla.Lang
{
    public variant TypeError {
        | Undefined {
            name: string;
            
            public override ToString(): string {
                $"$name type is not defined."
            }
        }
        | RecursiveReference { a: Type; b: Type }
        | Ambiguous { types: list[Type] }
        | UnificationFailure {
            refered: Type; referer: Type;
            
            public override ToString(): string {
                $"Could not unify type $refered and $referer."
            }
        }
        | InferenceUnmatched { types: list[Type] }
    }
    
    public interface TypeScope {
        resolveType(name: string): Type
    }
    
    public variant TypeHint: HasSpan[TypeHint] {
        | None
        | Name {
            name: string;
            
            public override ToString(): string {
                name
            }
        }
        | Fn {
            args: list[TypeHint]; ret: TypeHint;
            
            public override ToString(): string {
                def sb = StringBuilder();
                if (args.Length > 0) {
                    _ = sb.Append(args.Head.ToString());
                    foreach (arg in (args.Tail + [ret])) {
                        _ = sb.Append(" -> ").Append(arg.ToString());
                    }
                } else {
                    _ = sb.Append(ret.ToString());
                }
                sb.ToString()
            }
        }
        | Generics { _base: TypeHint; _params: list[TypeHint] }
        
        public resolve(scope: TypeScope): Type { match (this) {
            | TypeHint.None => Type.Unknown()
            | TypeHint.Name(name) => scope.resolveType(name)
            | TypeHint.Fn(args, ret) => Type.Fn(args.Map(arg => arg.resolve(scope)), ret.resolve(scope))
            | TypeHint.Generics(_base, _params) => Type.Generics(_base.resolve(scope), _params.Map(p => p.resolve(scope)))
        }}
        
        public static Unit(): TypeHint {
            Name(Type.UNIT_NAME)
        }
    }
    
    public variant Type: System.IEquatable[Type] {
        | Unknown {
            public override ToString(): string {
                "Unknown"
            }
        }
        | Var {
            public mutable instance: Type;
            
            public this() {
                instance = Unknown();
            }
            
            // VarがVarを参照する場合、途中の参照は無意味なので経路圧縮する
            // (間の型変数のinstanceは変わらないことが保証できる)
            public simplify(): Var {
                match (instance) {
                    | Var(v is Var) => {
                        instance = v
                    }
                    | _ => {}
                }
                this
            }
            
            public override ToString(): string {
                $"Var($instance)"
            }
        }
        | Class {
            public members: Hashtable[string, List[Type]] = Hashtable();
            public staticMembers: Hashtable[string, List[Type]] = Hashtable();
        }
        | Native {
            public type: System.Type;
            
            public override Equals(other: object): bool {
                match (other) {
                    | Native(t) => t.Equals(type)
                    | _ => false
                }
            }
            
            public override ToString(): string {
                $"Native($type)"
            }
        }
        | Fn {
            args: list[Type]; ret: Type;
            
            public override ToString(): string {
                def argsStr = Misc.joinToString(", ", args);
                $"Fn($argsStr): $ret"
            }
            
            public static from(methodInfo: System.Reflection.MethodInfo): Fn {
                def pTypes = methodInfo.GetParameters().Map(p => p.ParameterType);
                Fn(pTypes.Map(t => Type.Native(t)).ToNList(), Type.Native(methodInfo.ReturnType))
            }
        }
        | Generics { _base: Type; _params: list[Type] }
        | Error {
            public this(error: TypeError) {
                this.errors.Add(error);
            }
            
            public this(errors: IEnumerable[TypeError]) {
                this.errors.AddRange(errors);
            }
        }
        
        // Primery Types
        public static UNIT_NAME: string = "Unit";
        public static INT_NAME: string = "Int";
        public static STRING_NAME: string = "String";
        
        public errors: List[TypeError] = List();
        
        public canUnify(other: Type): bool {
            def op = other.resolved(); // ここでotherを解決する(最初だけ)
            _canUnify(op) // 再帰で処理
        }
        // 再帰用
        _canUnify(other: Type): bool {
            match ((this, other)) {
                | (Unknown, _) => true
                | (_, Unknown) => true
                | (e is Error, _) => false
                | (_, e is Error) => false
                | (Var(t), _) => t._canUnify(other)
                | (Fn(a, b), Fn(c, d)) when a.Length == c.Length => a.Zip(c).All((x,y) => x._canUnify(y)) && b._canUnify(d)
                | (Native(a), Native(b)) when a.Equals(b) => true // TODO ネイティブの継承を考慮する
                // TODO
                | _ => false
            }
        }
        
        public unify(other: Type): Type {
            // check already unified
            when (this.unVar() == other.unVar()) {
                return this;
            }
            
            match ((this, other)) {
                | (Unknown, _) => other
                | (_, Unknown) => this
                | (e is Error, _) => Type.Error(e.errors.ToNList() + [TypeError.UnificationFailure(this, other)])
                | (_, e is Error) => Type.Error(e.errors.ToNList() + [TypeError.UnificationFailure(other, this)])
                | (it is Var, _) => {
                    if (!it.occursIn(other)) {
                        it.instance = it.instance.unify(other);
                    } else {
                        it.instance = Type.Error(TypeError.RecursiveReference(this, other));
                    }
                    it.simplify()
                }
                | (_, it is Var) => {
                    it.instance = it.instance.unify(this); // thisが型変数じゃないのでotherをunifyして返す
                    it.simplify()
                }
                | (Fn(a, b), Fn(c, d)) when a.Length == c.Length => Fn(a.Zip(c).Map((x, y) => x.unify(y)), b.unify(d))
                | (Native(a), Native(b)) when a.Equals(b) => this // TODO ネイティブの継承を考慮する
                // TODO
                | _ => {
                    Type.Error(TypeError.UnificationFailure(this, other))
                }
            }
        }
        
        // thisは変更しないで型変数を可能な限り取り除く
        // TODO rename to "pruned"
        public resolved(): Type {
            match (this) {
                | Var(t) => t.resolved()
                | Fn(args, ret) => Fn(args.Map(_.resolved()), ret.resolved())
                | Generics(b, ps) => Generics(b.resolved(), ps.Map(_.resolved()))
                | _ => this
            }
        }
        
        // pruneと違って型関数内の型変数を置換しない
        public unVar(): Type {
            match (this) {
                | Var(t) => {
                    match (t) {
                        | it is Var => it.unVar()
                        | _ => t
                    }
                }
                | _ => this
            }
        }
            
        public occursIn(other: Type): bool {
            when (this == other) {
                return true
            }
            
            match (other) {
                | Var(t) => occursIn(t)
                | Fn(args, ret) => args.Any(arg => occursIn(arg)) || occursIn(ret)
                | Generics(b, ps) => occursIn(b) || ps.Any(p => occursIn(p))
                | _ => false
            }
        }
        
        public scanErrors(): IEnumerable[TypeError] {
            def ret = match (this) {
                | Var(t) => t.scanErrors()
                | Fn(args, ret) => args.SelectMany(_.scanErrors()).Concat(ret.scanErrors())
                | Generics(b, ps) => ps.SelectMany(_.scanErrors()).Concat(b.scanErrors())
                | _ => []
            };
            ret.Concat(errors)
        }
    }
}
