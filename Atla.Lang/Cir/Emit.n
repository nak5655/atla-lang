using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;

namespace Atla.Lang.Cir
{
    public class Emit
    {
        parent: option[Emit];
        
        public this(parent: option[Emit]) {
            this.parent = parent;
        }
        
        public emit(gen: ILGenerator, cir: Cir.Ins): void {
            match (cir) {
                | Cir.Ins.LdLoc(index) => {
                    match (index) {
                        | 0 => gen.Emit(OpCodes.Ldloc_0)
                        | 1 => gen.Emit(OpCodes.Ldloc_1)
                        | 2 => gen.Emit(OpCodes.Ldloc_2)
                        | 3 => gen.Emit(OpCodes.Ldloc_3)
                        | _ => gen.Emit(OpCodes.Ldloc, index)
                    }
                }
                | Cir.Ins.LdArg(index) => {
                    match (index) {
                        | 0 => gen.Emit(OpCodes.Ldarg_0)
                        | 1 => gen.Emit(OpCodes.Ldarg_1)
                        | 2 => gen.Emit(OpCodes.Ldarg_2)
                        | 3 => gen.Emit(OpCodes.Ldarg_3)
                        | _ => gen.Emit(OpCodes.Ldarg, index)
                    }
                }
                | Cir.Ins.LdStr(str) => gen.Emit(OpCodes.Ldstr, str)
                | Cir.Ins.Call(method) => gen.Emit(OpCodes.Call, method)
                | Cir.Ins.Ret => gen.Emit(OpCodes.Ret)
                | Cir.Ins.Nop => gen.Emit(OpCodes.Nop)
            }
        }
        
        
        public emit(cir: Cir.Method): void {
            def gen = cir.builder.GetILGenerator();
            foreach (ins in cir.body) {
                emit(gen, ins);
            }
        }
        
        public emit(cir: Cir.Type): void {
            foreach (method in cir.methods) {
                emit(method);
            }
        }
        
        public emit(cir: Cir.Module) : void {
            foreach (cls in cir.types) {
                emit(cls);
            }
            
            cir.builder.CreateGlobalFunctions();
        }
        
        public emit(cir: Cir.Assembly) : void {
            
            // TODO: check arg type and ret type
            mutable foundMain = false;
            foreach (mod in cir.modules) {
                foreach (method in mod.methods) {
                   when (method.builder.Name == "main") {
                        cir.builder.SetEntryPoint(method.builder);
                        foundMain = true;
                        break;
                    }
                }
                when (foundMain)
                    break;
            }
        }
    }
}
